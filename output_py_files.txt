

=== Folder: . ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\addConfig.py ---
# addConfig.py
from app import create_app, db
from app.models import MasterConfig, Priority
from datetime import datetime

def insert_master_configs():
    configs = [
        ("MAX_ESCALATION_LEVEL", "3"),
        ("SLA_CLOSURE_DAYS", "7"),
        ("DEFAULT_PRIORITY", Priority.MEDIUM.value),  # Use enum value
    ]

    inserted, updated = 0, 0
    for key, value in configs:
        config = MasterConfig.query.filter_by(key=key).first()
        if config:
            config.value = value
            config.updated_at = datetime.utcnow()
            updated += 1
        else:
            new_config = MasterConfig(key=key, value=value)
            db.session.add(new_config)
            inserted += 1

    db.session.commit()
    print(f"✅ Inserted {inserted}, Updated {updated} master_configs successfully!")

if __name__ == "__main__":
    app = create_app()
    with app.app_context():
        insert_master_configs()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\addData.py ---
# addData.py

from app import create_app, db   # use your factory or app instance
from app.models import MasterAreas  # adjust import if needed

def insert_master_areas():
    areas = [
        ("Nigdi-Prdhikaran", "निगडी - प्राधिकरण"),
        ("Akurdi", "आकुर्डी"),
        ("Chinchwadgaon", "चिंचवडगांव"),
        ("Thergaon", "थेरगांव"),
        ("Kiwale", "किवळे"),
        ("Ravet", "रावेत"),
        ("Mamurdi", "मामुर्डी"),
        ("Wakad", "वाकड"),
        ("Punawale", "पुनावळे"),
        ("Bopkhel", "बोपखेल"),
        ("Dapodi-Fugewadi", "दापोडी फुगेवाडी"),
        ("Talawade", "तळवडे"),
        ("Morwadi", "मोरवाडी"),
        ("Bhosari", "भोसरी"),
        ("Chikhali", "चिखली"),
        ("Charholi", "च-होली"),
        ("Moshi", "मोशी"),
        ("Pimprigaon", "पिंपरीगांव"),
        ("Kharalwadi", "खराळवाडी"),
        ("Kasarwadi", "कासारवाडी"),
        ("Kalewadi-Rahatani", "काळेवाडी रहाटणी"),
        ("Chinchwad-Station", "चिंचवड स्टेशन"),
        ("Pimple-Nilakh", "पिंपळे निलख"),
        ("Pimple-Saudagar", "पिंपळे सौदागर"),
        ("Pimple-Gurav", "पिंपळे गुरव"),
        ("New-Sangvi", "नवी सांगवी"),
        ("Old-Sangvi", "जुनी सांगवी"),
        ("Sambhaji-Nagar", "संभाजीनगर"),
        ("Sant-Tukaram-Nagar", "संत तुकाराम नगर"),
        ("Nehru-Nagar", "नेहरूनगर"),
        ("Pimpri-Camp", "पिंपरी कॅम्प"),
        ("Yamuna-Nagar", "यमुनानगर"),
        ("Masulkar-Colony", "मासुळकर कॉलनी"),
        ("Dighi", "दिघी"),
        ("Tathawade", "ताथवडे"),
        ("Dudulgaon", "डुडूळगांव"),
        ("Wadmukhwadi", "वडमुखवाडी"),
        ("AII-PCMC", "पिं.चिं. शहर"),
        ("Walhekar Wadi", "वाल्हेकरवाडी"),
        ("Bhatnagar", "भाटनगर"),
        ("Jadhavwadi-KudalWadi", "जाधववाडी-कुदळवाडी"),
        ("Indrayani Nagar", "इंद्रायणी नगर"),
        ("Rupi Nagar", "रुपीनगर"),
        ("Kalbhor Nagar", "काळभोरनगर"),
        ("Chinchwade Nagar", "चिंचवडेनगर"),
        ("Shivtej Nagar Chikhali", "शिवतेज नगर चिखली"),
    ]

    objects = [MasterAreas(name=name, description=desc) for name, desc in areas]
    db.session.bulk_save_objects(objects)
    db.session.commit()
    print(f"✅ Inserted {len(objects)} master_areas successfully!")

if __name__ == "__main__":
    app = create_app()  # if you use app factory pattern
    with app.app_context():
        insert_master_areas()

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\addData_Subject.py ---
# addSubjects.py

from app import create_app, db   # adjust if you import app directly
from app.models import MasterSubjects  # make sure MasterSubject model exists

def insert_master_subjects():
    subjects = [
        ("रस्त्यावरील खड्डयांबाबत", "Pot Holes"),
        ("सार्वजनिक शौचालय साफसफाईबाबत", "Cleaning of Public Toilets"),
        ("अनाधिकृत टपऱ्या / हातगाड्या / फेरीवाल्यांबाबत", "Unauthorised Stalls & Hawkers"),
        ("अनाधिकृत मोबाईल टॉवरबाबत", "Unauthorised Mobile Tower"),
        ("किटकनाशक फवारणी", "Spraying Of Pesticides"),
        ("रस्ते दुरूस्ती", "Road repairing"),
        ("पाणी समस्या", "Water problem"),
        ("ड्रेनेज तुंबलेबाबत", "Drainage blockage"),
        ("रस्त्यावरील विद्युत दिव्यांबाबत", "Street lights"),
        ("परिसर साफसफाई / कचरा उचलणेबाबत", "Area Cleaning / Garbage lifting"),
        ("ध्वनी प्रदुषणाबाबत", "Sound Pollution"),
        ("इतर", "Other"),
        ("मृत जनावर", "Dead animal"),
        ("कचराकुंडी साफ नाहीत", "Dustbins not cleaned"),
        ("कचरा गाडीबाबत", "Garbage vehicle not arrived"),
        ("सार्वजनिक स्वच्छतागृहातील विदयुत दिव्याबाबत", "No electricity in public toilet"),
        ("सार्वजनिक स्वच्छतागृहातील पाणी समस्याबाबत", "No water supply in public toilet"),
        ("सार्वजनिक स्वच्छतागृहातील साफसफाईबाबत", "Public toilet blockage-cleaning"),
        ("गतिरोधक", "Speed Breaker"),
        ("कमी दाबाने पाणी पुरवठा", "Low Water Pressure"),
        ("दुषित पाणी पुरवठा", "Contaminated Water Supply"),
        ("अनियमित पाणी पुरवठा", "Irregular Water Supply"),
        ("पाईपलाईन लीकेज", "Pipeline Leakage"),
        ("पेविंग ब्लॉक", "Paving Block"),
        ("वृक्ष छाटणी", "Tree Cutting"),
        ("फुटपाथ दुरुस्ती बाबत", "Regarding pavement repair"),
        ("फुटपाथ साफसफाई बाबत", "Clean Sidewalk"),
        ("भटक्या कुत्र्यांसाठी जन्म नियंत्रण बाबत", "Birth Control for Stray Dogs"),
        ("आजारी किंवा जखमी भटका कुत्रा बाबत", "Sick or Injured Stray Dog"),
        ("भटक्या कुत्र्याने चावा बाबत", "Bite by Stray Dog"),
        ("मोठे मृत जनावरांची विल्हेवाट लावणे बाबत", "Disposal of large dead animals"),
        ("रेबीज ग्रस्त श्वानांची तक्रार बाबत", "Complaints of rabies dogs"),
    ]

    objects = [MasterSubjects(name=eng, description=mar) for mar, eng in subjects]
    db.session.bulk_save_objects(objects)
    db.session.commit()
    print(f"✅ Inserted {len(objects)} master_subjects successfully!")

if __name__ == "__main__":
    app = create_app()  # if you use factory pattern
    with app.app_context():
        insert_master_subjects()

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\create_databse.py ---
from app import create_app, db  # adjust if your app factory is named differently

app = create_app()

with app.app_context():
    db.drop_all()
    db.create_all()
    print("Database reset and tables created successfully!")

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\run.py ---
# run.py

from app import create_app,db

app = create_app()

# with app.app_context():
#     db.create_all()
if __name__ == '__main__':
    app.run(debug=True)
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\seedData.py ---
# seed_data.py

from datetime import datetime, timedelta, timezone
from app import create_app, db
from app.models import (
    User, Role, Grievance, GrievanceStatus, Priority,
    MasterSubjects, MasterAreas, MasterCategories
)

# Create Flask app context
app = create_app()

with app.app_context():
    # Drop & recreate (⚠️ optional – remove drop_all if you want to keep data)
    # db.drop_all()
    # db.create_all()

    # --- Master Data ---
    roads = MasterCategories(name="Roads", description="Road-related issues")
    sanitation = MasterCategories(name="Sanitation", description="Garbage, sewage, etc.")
    db.session.add_all([roads, sanitation])
    db.session.commit()

    subject_potholes = MasterSubjects(name="Potholes", description="Report potholes on roads", category=roads)
    subject_garbage = MasterSubjects(name="Garbage", description="Uncollected garbage", category=sanitation)
    db.session.add_all([subject_potholes, subject_garbage])
    db.session.commit()

    area_central = MasterAreas(name="Central Ward", description="Main city area")
    area_north = MasterAreas(name="North Ward", description="Northern side of the city")
    db.session.add_all([area_central, area_north])
    db.session.commit()

    # --- Users ---
    # admin = User(name="Admin User", email="admin@test.com", role=Role.ADMIN, department_id=area_central.id)
    # admin.set_password("admin123")

    # citizen = User(name="John Citizen", email="citizen@test.com", role=Role.CITIZEN, department_id=area_north.id)
    # citizen.set_password("citizen123")

    # staff = User(name="Field Staff", email="staff@test.com", role=Role.FIELD_STAFF, department_id=area_central.id)
    # staff.set_password("staff123")

    # db.session.add_all([admin, citizen, staff])
    # db.session.commit()

    # --- Grievances ---
    grievance1 = Grievance(
        citizen_id=1,
        subject_id=subject_potholes.id,
        area_id=area_central.id,
        title="Big pothole near market",
        description="A large pothole causing traffic jams.",
        ward_number="12",
        status=GrievanceStatus.NEW,
        priority=Priority.HIGH,
        latitude=18.5204,
        longitude=73.8567,
        address="Market Road, Central Ward",
        escalation_level=0
    )

    grievance2 = Grievance(
        citizen_id=1,
        subject_id=subject_garbage.id,
        area_id=area_north.id,
        title="Garbage not collected",
        description="Garbage has been piling up for 3 days.",
        ward_number="7",
        status=GrievanceStatus.IN_PROGRESS,
        priority=Priority.MEDIUM,
        assigned_to=3,
        assigned_by=4,
        latitude=18.5304,
        longitude=73.8667,
        address="Street 21, North Ward",
        escalation_level=1,
        created_at=datetime.now(timezone.utc) - timedelta(days=2)
    )

    db.session.add_all([grievance1, grievance2])
    db.session.commit()

    print("✅ Sample data inserted successfully!")

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\testusers.py ---
# # create_users.py
# from app import create_app, db
# from app.models import User, Role
# from datetime import datetime, timezone

# def create_test_users():
#     users = [
#         {
#             "name": "Test Citizen",
#             "email": "citizen@test.com",
#             "phone_number": "+1234567890",
#             "password": "password123",
#             "role": Role.CITIZEN,
#             "department_id": None
#         },
#         {
#             "name": "Test Member Head",
#             "email": "memberhead@test.com",
#             "phone_number": "+1234567891",
#             "password": "password123",
#             "role": Role.MEMBER_HEAD,
#             "department_id": 1  # Assumes area ID 1 exists
#         },
#         {
#             "name": "Test Field Staff",
#             "email": "fieldstaff@test.com",
#             "phone_number": "+1234567892",
#             "password": "password123",
#             "role": Role.FIELD_STAFF,
#             "department_id": 1
#         },
#         {
#             "name": "Test Admin",
#             "email": "admin@test.com",
#             "phone_number": "+1234567893",
#             "password": "password123",
#             "role": Role.ADMIN,
#             "department_id": None
#         }
#     ]

#     for user_data in users:
#         # Check if user already exists
#         if User.query.filter_by(email=user_data["email"]).first():
#             print(f"User {user_data['email']} already exists, skipping.")
#             continue
        
#         user = User(
#             name=user_data["name"],
#             email=user_data["email"],
#             phone_number=user_data["phone_number"],
#             role=user_data["role"],
#             department_id=user_data["department_id"],
#             created_at=datetime.now(timezone.utc),
#             updated_at=datetime.now(timezone.utc)
#         )
#         user.set_password(user_data["password"])
#         db.session.add(user)
#         print(f"Created user: {user_data['name']} ({user_data['role'].value})")
    
#     db.session.commit()
#     print("✅ All users created successfully!")

# if __name__ == "__main__":
#     app = create_app()
#     with app.app_context():
#         create_test_users()








# create_users.py
from app import create_app, db
from app.models import User, Role
from datetime import datetime, timezone

def create_test_users():
    users = [
        {
            "name": "Gest Staff2",
            "email": "Gest@test.com2",
            "phone_number": "+2234567898",
            "password": "password123",
            "role": Role.FIELD_STAFF,
            "department_id": 1
        },
        {
            "name": "Gest Staff3",
            "email": "Gest@test.com3",
            "phone_number": "+3234567894",
            "password": "password123",
            "role": Role.FIELD_STAFF,
            "department_id": 1
        },
        {
            "name": "Gest Staff4",
            "email": "Gest@test.com4",
            "phone_number": "+4234567895",
            "password": "password123",
            "role": Role.FIELD_STAFF,
            "department_id": 1
        }
    ]

    for user_data in users:
        # Check if user already exists
        if User.query.filter_by(email=user_data["email"]).first():
            print(f"User {user_data['email']} already exists, skipping.")
            continue
        
        user = User(
            name=user_data["name"],
            email=user_data["email"],
            phone_number=user_data["phone_number"],
            role=user_data["role"],
            department_id=user_data["department_id"],
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )
        user.set_password(user_data["password"])
        db.session.add(user)
        print(f"Created user: {user_data['name']} ({user_data['role'].value})")
    
    db.session.commit()
    print("✅ All users created successfully!")

if __name__ == "__main__":
    app = create_app()
    with app.app_context():
        create_test_users()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\test_all_routes.py ---
import requests
import json

BASE_URL = "http://127.0.0.1:5000"

# Test users
USERS = {
    "citizen": "citizen@test.com",
    "member_head": "memberhead@test.com",
    "field_staff": "fieldstaff@test.com",
    "admin": "admin@test.com",
}
PASSWORD = "password123"

# Endpoints from flask routes (placeholders replaced)
ROUTES = [
    ("GET", "/admins/kpis/advanced"),
    ("GET", "/admins/users/history"),
    ("GET", "/admins/audit-logs"),
    ("GET", "/admins/users/1/history"),
    ("POST", "/admins/announcements"),
    ("GET", "/admins/dashboard"),
    ("POST", "/admins/grievances/1/escalate"),
    ("GET", "/admins/reports/kpis/advanced"),
    ("GET", "/admins/grievances/all"),
    ("GET", "/admins/announcements"),
    ("GET", "/admins/areas"),
    ("GET", "/admins/subjects"),
    ("GET", "/admins/users"),
    ("GET", "/admins/reports/location"),
    ("POST", "/admins/areas"),
    ("GET", "/admins/configs"),
    ("POST", "/admins/configs"),
    ("POST", "/admins/subjects"),
    ("POST", "/admins/reassign/1"),
    ("GET", "/admins/reports"),
    ("GET", "/admins/reports/staff-performance"),
    ("PUT", "/admins/configs/MAX_ESCALATION_LEVEL"),
    ("PUT", "/admins/users/1"),
    ("GET", "/auth/me"),
    ("GET", "/auth/google/callback"),
    ("GET", "/auth/google/login"),
    ("POST", "/auth/guest-login"),
    ("POST", "/auth/login"),
    ("POST", "/auth/refresh"),
    ("POST", "/auth/register"),
    ("POST", "/auth/otp/send"),
    ("POST", "/auth/otp/verify"),
    ("POST", "/grievances/1/accept"),
    ("POST", "/grievances/1/comments"),
    ("GET", "/grievances/assigned"),
    ("POST", "/grievances/1/close"),
    ("POST", "/grievances/"),
    ("POST", "/grievances/1/escalate"),
    ("GET", "/grievances/admin/grievances/all"),
    ("GET", "/grievances/1"),
    ("GET", "/grievances/admin/1"),
    ("GET", "/grievances/mine"),
    ("GET", "/grievances/new"),
    ("PUT", "/grievances/1/reassign"),
    ("POST", "/grievances/1/reject"),
    ("GET", "/grievances/1/rejection"),
    ("GET", "/grievances/search/TEST123"),
    ("POST", "/grievances/1/feedback"),
    ("GET", "/grievances/track"),
    ("PUT", "/grievances/1/status"),
    ("POST", "/grievances/1/workproof"),
    ("POST", "/notifications/register"),
    ("GET", "/areas"),
    ("GET", "/subjects"),
    ("GET", "/settings/settings"),
    ("POST", "/settings/settings"),
    ("GET", "/users/admin/users"),
    ("POST", "/users/admin/users"),
    ("DELETE", "/users/admin/users/1"),
    ("GET", "/users/1"),
    ("GET", "/users/"),
]

def login(email, password):
    url = f"{BASE_URL}/auth/login"
    resp = requests.post(url, json={"email": email, "password": password})
    if resp.status_code == 200 and "access_token" in resp.json():
        return resp.json()["access_token"]
    print(f"❌ Login failed for {email}: {resp.status_code} {resp.text}")
    return None

def pretty_json(data, length=200):
    """Return truncated JSON for logging"""
    try:
        txt = json.dumps(data, indent=2)
        return txt[:length] + ("..." if len(txt) > length else "")
    except Exception:
        return str(data)

def test_routes_for_user(role, token):
    print(f"\n=== Testing routes for {role.upper()} ===")
    headers = {"Authorization": f"Bearer {token}"} if token else {}

    for method, route in ROUTES:
        url = f"{BASE_URL}{route}"
        try:
            if method == "GET":
                resp = requests.get(url, headers=headers)
            elif method == "POST":
                resp = requests.post(url, headers=headers, json={})
            elif method == "PUT":
                resp = requests.put(url, headers=headers, json={})
            elif method == "DELETE":
                resp = requests.delete(url, headers=headers)
            else:
                continue

            status = resp.status_code
            out = f"{method:6s} {route:40s} => {status}"

            # Add response details
            if status == 200:
                try:
                    out += f" | {pretty_json(resp.json())}"
                except Exception:
                    out += f" | {resp.text[:100]}"
            else:
                out += f" | {resp.reason} {resp.text[:80]}"

            print(out)

        except Exception as e:
            print(f"{method:6s} {route:40s} => ERROR {e}")

if __name__ == "__main__":
    for role, email in USERS.items():
        token = login(email, PASSWORD)
        test_routes_for_user(role, token)


=== Folder: .pytest_cache ===


=== Folder: .pytest_cache\v ===


=== Folder: .pytest_cache\v\cache ===


=== Folder: app ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\admin_views.py ---
# app/admin_views.py
from flask_admin.contrib.sqla import ModelView
from flask_admin import BaseView, expose
from flask_security import current_user
from .models import User, Grievance, MasterSubjects, MasterAreas, MasterCategories, AuditLog, Announcement
from . import db

class SecureModelView(ModelView):
    """Base view with access checks."""
    def is_accessible(self):
        return current_user.is_authenticated and current_user.role == Role.ADMIN
    
    def inaccessible_callback(self, name, **kwargs):
        return redirect(url_for('security.login', next=request.url))

# Custom Dashboard View (example: show KPIs)
class DashboardView(BaseView):
    @expose('/')
    def index(self):
        # Fetch some stats (reuse your kpi_utils if needed)
        total_grievances = Grievance.query.count()
        return self.render('admin/dashboard.html', total_grievances=total_grievances)  # Create this template later

# Model Views
class UserAdmin(SecureModelView):
    column_exclude_list = ['password_hash']  # Hide sensitive fields
    column_searchable_list = ['name', 'email']
    column_filters = ['role']
    form_excluded_columns = ['password_hash']  # Don't edit hash directly
    can_export = True  # Allow CSV export

class GrievanceAdmin(SecureModelView):
    column_list = ['id', 'title', 'status', 'priority', 'created_at']
    column_searchable_list = ['title', 'description']
    column_filters = ['status', 'priority', 'area.name']
    form_excluded_columns = ['attachments', 'comments']  # Handle separately if needed
    can_export = True

# Add more for other models...
class SubjectAdmin(SecureModelView):
    pass

class AreaAdmin(SecureModelView):
    pass

class CategoryAdmin(SecureModelView):
    pass

class AuditLogAdmin(SecureModelView):
    can_edit = False  # Read-only
    can_delete = False

class AnnouncementAdmin(SecureModelView):
    pass
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\config.py ---
# app/config.py

import os
from datetime import timedelta
from dotenv import load_dotenv

# The base directory of the application
basedir = os.path.abspath(os.path.dirname(__file__))

# Load environment variables from a .env file at the project root
# This is useful for development.
# Create a .env file in the root directory and add your environment-specific variables there.
# See .env.example for a template.
load_dotenv(os.path.join(basedir, '..', '.env'))

class Config:
    """
    Base configuration class.
    Contains default configuration settings and settings loaded from environment variables.
    """
    # --- General Flask Settings ---
    # A secret key is required for session management, flash messages, and other security features.
    # In production, this MUST be a long, random, and secret string.
    # You can generate one using: python -c 'import secrets; print(secrets.token_hex(16))'
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'a-hard-to-guess-string-for-dev'

    # --- Database Settings ---
    # Defines the database connection URI.
    # The default is an SQLite database named 'app.db' in the project root, which is good for development.
    # For production, you should use a more robust database like PostgreSQL or MySQL.
    # Example for PostgreSQL: DATABASE_URL="postgresql://user:password@host:port/dbname"
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or f'sqlite:///{os.path.join(basedir, "..", "app.db")}'
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    # --- JWT (JSON Web Token) Settings ---
    # Secret key for signing JWTs. This should also be a strong, secret value in production.
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'another-super-secret-jwt-key-for-dev'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=60)

    # --- File Upload Settings ---
    UPLOAD_FOLDER = os.path.join(basedir, '..', 'uploads')
    ALLOWED_EXTENSIONS = {'pdf', 'txt', 'jpg', 'jpeg', 'png', 'mp4', 'mov'}
    MAX_CONTENT_LENGTH = 50 * 1024 * 1024  # 16MB max file size


    # Security Settings (for Flask-Security-Too)
    SECURITY_PASSWORD_SALT = os.environ.get('SECURITY_PASSWORD_SALT') or 'a-salt-for-hashing'
    SECURITY_TRACKABLE = True  # Track logins
    SECURITY_REGISTERABLE = False  # Disable public registration (admins only)
    SECURITY_SEND_REGISTER_EMAIL = False
    SECURITY_LOGIN_URL = '/admin/login'  # Custom login for admin
    SECURITY_LOGOUT_URL = '/admin/logout'
    SECURITY_POST_LOGIN_VIEW = '/admin/'  # Redirect to admin after login
    SECURITY_POST_LOGOUT_VIEW = '/auth/login'  # Back to main login
    SECURITY_UNAUTHORIZED_VIEW = '/auth/unauthorized'  # Handle forbidden access


    # --- Email Settings ---
    # To send emails, you need to configure an SMTP server.
    # For development, you can use a service like Mailtrap.io or a local debugging server.
    # The settings below are configured to use environment variables, with Google's SMTP as the default.
    # For this to work, you must enable 2-Step Verification on your Google account and generate an "App Password".
    # If you don't set these in your .env, email sending will likely fail.
    # MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'smtp.gmail.com'
    # MAIL_PORT = int(os.environ.get('MAIL_PORT') or 587)
    # MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'True').lower() in ('true', '1', 't')
    # MAIL_USE_SSL = os.environ.get('MAIL_USE_SSL', 'False').lower() in ('true', '1', 't')
    # MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    # MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    # MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER') or ('Grievance System', os.environ.get('MAIL_USERNAME'))

    # --- Google OAuth Settings ---
    # These are required for Google Sign-In to work.
    # You must create a project in the Google Cloud Console (https://console.cloud.google.com/)
    # and get "OAuth 2.0 Client ID" credentials.
    # If these are not set, the Google login feature should be disabled or handled gracefully in the code.
    GOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID')
    GOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET')
    GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"


--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\extensions.py ---
from authlib.integrations.flask_client import OAuth

oauth = OAuth()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\models.py ---
# app/models.py

from datetime import datetime, timezone
from werkzeug.security import generate_password_hash, check_password_hash
from . import db
from enum import Enum
import uuid


class Role(Enum):
    CITIZEN = 'citizen'
    MEMBER_HEAD = 'member_head'
    FIELD_STAFF = 'field_staff'
    ADMIN = 'admin'

class GrievanceStatus(Enum):
    NEW = 'new'
    IN_PROGRESS = 'in_progress'
    ON_HOLD = 'on_hold'
    RESOLVED = 'resolved'
    CLOSED = 'closed'
    REJECTED = 'rejected'

class Priority(Enum):
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    URGENT = 'urgent'

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(128), unique=True, nullable=True)
    phone_number = db.Column(db.String(15), unique=True, nullable=True)
    voter_id = db.Column(db.String(50), unique=True, nullable=True)
    password_hash = db.Column(db.String(256), nullable=True)
    role = db.Column(db.Enum(Role), nullable=False)
    department_id = db.Column(db.Integer, db.ForeignKey('master_areas.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    # New fields for enhanced user profile
    address = db.Column(db.String(256), nullable=True)  # For user address in settings
    profile_picture = db.Column(db.String(256), nullable=True)  # Path to profile picture
    last_login = db.Column(db.DateTime, nullable=True)  # Track last login for security
    two_factor_enabled = db.Column(db.Boolean, default=False)  # For 2FA in settings
    is_active = db.Column(db.Boolean, default=True)  # For account status (e.g., disable user)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Grievance(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    complaint_id = db.Column(db.String(50), unique=True, nullable=False, default=lambda: str(uuid.uuid4())[:8])
    citizen_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    subject_id = db.Column(db.Integer, db.ForeignKey('master_subjects.id'), nullable=False)
    area_id = db.Column(db.Integer, db.ForeignKey('master_areas.id'), nullable=False)
    title = db.Column(db.String(256), nullable=False)
    description = db.Column(db.Text, nullable=False)
    ward_number = db.Column(db.String(50), nullable=True)
    status = db.Column(db.Enum(GrievanceStatus), default=GrievanceStatus.NEW, nullable=False)
    priority = db.Column(db.Enum(Priority), default=Priority.MEDIUM, nullable=True)
    assigned_to = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    assigned_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    rejection_reason = db.Column(db.Text, nullable=True)
    resolved_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    latitude = db.Column(db.Float, nullable=True)
    longitude = db.Column(db.Float, nullable=True)
    address = db.Column(db.String(256), nullable=True)
    escalation_level = db.Column(db.Integer, default=0)
    feedback_rating = db.Column(db.Integer, nullable=True)  # 1-5 star rating
    feedback_text = db.Column(db.Text, nullable=True)
    # New field for categorization
    category_id = db.Column(db.Integer, db.ForeignKey('master_categories.id'), nullable=True)  # For grouping subjects

    # Relationships
    citizen = db.relationship('User', backref=db.backref('submitted_grievances', lazy=True), foreign_keys=[citizen_id])
    assignee = db.relationship('User', backref=db.backref('assigned_grievances', lazy=True), foreign_keys=[assigned_to])
    assigner = db.relationship('User', backref=db.backref('assigned_by_grievances', lazy=True), foreign_keys=[assigned_by])
    subject = db.relationship('MasterSubjects')
    area = db.relationship('MasterAreas')
    category = db.relationship('MasterCategories')
    attachments = db.relationship('GrievanceAttachment', backref='grievance', lazy='dynamic', cascade="all, delete-orphan")
    comments = db.relationship('GrievanceComment', backref='grievance', lazy='dynamic', cascade="all, delete-orphan")
    def to_dict(self):
        """
        Convert Grievance object to a dictionary for JSON serialization.
        """
        # Convert dynamic relationships to lists
        attachments_list = [attachment.to_dict() for attachment in self.attachments.all()]
        comments_list = [comment.to_dict() for comment in self.comments.all()]
        
        return {
            'id': self.id,
            'complaint_id': self.complaint_id,
            'citizen_id': self.citizen_id,
            'citizen': {
                'id': self.citizen.id,
                'name': self.citizen.name
            } if self.citizen else None,
            'subject_id': self.subject_id,
            'subject': {
                'id': self.subject.id,
                'name': self.subject.name,
                'description': self.subject.description,
                'category': {
                    'id': self.subject.category.id,
                    'name': self.subject.category.name,
                    'description': self.subject.category.description
                } if self.subject.category else None
            } if self.subject else None,
            'area_id': self.area_id,
            'area': {
                'id': self.area.id,
                'name': self.area.name,
                'description': self.area.description
            } if self.area else None,
            'title': self.title,
            'description': self.description,
            'ward_number': self.ward_number,
            'status': self.status.value if self.status else None,
            'priority': self.priority.value if self.priority else None,
            'assigned_to': self.assigned_to,
            'assignee': {
                'id': self.assignee.id,
                'name': self.assignee.name
            } if self.assignee else {'id': 0, 'name': 'Unassigned'},
            'assigned_by': self.assigned_by,
            'assigner': {
                'id': self.assigner.id,
                'name': self.assigner.name
            } if self.assigner else None,
            'rejection_reason': self.rejection_reason,
            'resolved_at': self.resolved_at.isoformat() if self.resolved_at else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'latitude': self.latitude,
            'longitude': self.longitude,
            'address': self.address,
            'escalation_level': self.escalation_level,
            'feedback_rating': self.feedback_rating,
            'feedback_text': self.feedback_text,
            'category_id': self.category_id,
            'category': {
                'id': self.category.id,
                'name': self.category.name,
                'description': self.category.description
            } if self.category else None,
            'attachments': attachments_list,  # Use the converted list
            'comments': comments_list  # Use the converted list
        }
class GrievanceAttachment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=False)
    file_path = db.Column(db.String(256), nullable=False)
    file_type = db.Column(db.String(10), nullable=False)  # e.g., 'pdf', 'jpeg'
    file_size = db.Column(db.Integer, nullable=True)  # New: Store file size for validation
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    def to_dict(self):
        return {
            'id': self.id,
            'grievance_id': self.grievance_id,
            'file_path': self.file_path,
            'file_type': self.file_type,
            'file_size': self.file_size,
            'uploaded_at': self.uploaded_at.isoformat() if self.uploaded_at else None
        }

class GrievanceComment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    comment_text = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    # New field for comment visibility
    is_public = db.Column(db.Boolean, default=True)  # Public or internal (e.g., for staff only)
    attachments = db.relationship('CommentAttachment', backref='comment', lazy='dynamic', cascade="all, delete-orphan")
    # Relationship to User
    user = db.relationship('User', backref='comments')
    def to_dict(self):
        # Convert dynamic relationship to list
        attachments_list = [attachment.to_dict() for attachment in self.attachments.all()]
        
        return {
            'id': self.id,
            'grievance_id': self.grievance_id,
            'user_id': self.user_id,
            'comment_text': self.comment_text,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'is_public': self.is_public,
            'attachments': attachments_list,  # Include comment attachments
            'user': {
                'id': self.user.id,
                'name': self.user.name
            } if self.user else None
        }


class CommentAttachment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    comment_id = db.Column(db.Integer, db.ForeignKey('grievance_comment.id'), nullable=False)
    file_path = db.Column(db.String(256), nullable=False)
    file_type = db.Column(db.String(10), nullable=True)  # e.g., 'jpg', 'pdf'
    file_size = db.Column(db.Integer, nullable=True)  # In bytes
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    def to_dict(self):
        return {
            'id': self.id,
            'comment_id': self.comment_id,
            'file_path': self.file_path,
            'file_type': self.file_type,
            'file_size': self.file_size,
            'uploaded_at': self.uploaded_at.isoformat() if self.uploaded_at else None
        }


class Workproof(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=False)
    uploaded_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    file_path = db.Column(db.String(256), nullable=False)
    file_type = db.Column(db.String(10), nullable=True)  # New: Store file type
    file_size = db.Column(db.Integer, nullable=True)  # New: Store file size
    notes = db.Column(db.Text, nullable=True)
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    # Relationship
    uploader = db.relationship('User', backref='workproofs')

class MasterSubjects(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    description = db.Column(db.Text, nullable=True)
    # New field for categorization
    category_id = db.Column(db.Integer, db.ForeignKey('master_categories.id'), nullable=True)
    is_active = db.Column(db.Boolean, default=True)  # New: Enable/disable subjects

    # Relationship
    category = db.relationship('MasterCategories', backref='subjects')

class MasterAreas(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    description = db.Column(db.Text, nullable=True)
    is_active = db.Column(db.Boolean, default=True)  # New: Enable/disable areas

class MasterCategories(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)  # e.g., 'Roads', 'Sanitation'
    description = db.Column(db.Text, nullable=True)
    is_active = db.Column(db.Boolean, default=True)  # New: Enable/disable categories

class AuditLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    action = db.Column(db.Text, nullable=False)
    action_type = db.Column(db.String(50), nullable=True)  # New: e.g., 'create', 'update', 'delete'
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=True)
    details = db.Column(db.Text, nullable=True)  # New: Additional context (e.g., JSON of changes)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    # Relationship
    performer = db.relationship('User', backref='audit_logs')

class OtpToken(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    phone_number = db.Column(db.String(15), nullable=False)
    otp = db.Column(db.String(6), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)
    used = db.Column(db.Boolean, default=False)  # New: Track if OTP was used
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

class NotificationToken(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    fcm_token = db.Column(db.String(256), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    is_active = db.Column(db.Boolean, default=True)  # New: Enable/disable token

    # Relationship
    user = db.relationship('User', backref='notification_tokens')

class MasterConfig(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(128), unique=True, nullable=False)
    value = db.Column(db.String(256), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    description = db.Column(db.Text, nullable=True)  # New: Describe config purpose

class Announcement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(256), nullable=False)
    message = db.Column(db.Text, nullable=False)
    type = db.Column(db.String(50), default="general")  # general / emergency
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    expires_at = db.Column(db.DateTime, nullable=True)  # New: Expiration for announcements
    target_role = db.Column(db.Enum(Role), nullable=True)  # New: Target specific roles
    is_active = db.Column(db.Boolean, default=True)  # New: Enable/disable announcements

class UserPreference(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    notifications_enabled = db.Column(db.Boolean, default=True)  # Notification preference
    language = db.Column(db.String(10), default='en')  # Language (e.g., 'en', 'mr', 'hi')
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    # Relationship
    user = db.relationship('User', backref='preferences')
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\schemas.py ---
from marshmallow import Schema, fields, validate, validates, ValidationError
from marshmallow_enum import EnumField
from .models import Role, GrievanceStatus, Priority

class UserSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    email = fields.Email(required=True)
    phone_number = fields.Str(allow_none=True)
    password = fields.Str(load_only=True, validate=validate.Length(min=6), allow_none=True)
    role = EnumField(Role, by_value=True, required=True)
    department_id = fields.Int(allow_none=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    voter_id = fields.String()
    # New fields from updated User model
    address = fields.Str(allow_none=True)
    profile_picture = fields.Str(allow_none=True)
    last_login = fields.DateTime(dump_only=True)
    two_factor_enabled = fields.Boolean(dump_only=True)
    is_active = fields.Boolean(dump_only=True)

    @validates('name')
    def validate_name(self, value):
        if value is None or value.strip() == '':
            raise ValidationError('Name cannot be empty or null')

class GrievanceSchema(Schema):
    id = fields.Int(dump_only=True)
    complaint_id = fields.Str(dump_only=True)
    title = fields.Str(required=True)
    description = fields.Str(required=True)
    # --- Fields for LOADING data (API input from user) ---
    subject_id = fields.Int(required=True, load_only=True)
    area_id = fields.Int(required=True, load_only=True)
    # New field
    category_id = fields.Int(allow_none=True, load_only=True)
    # Location fields
    latitude = fields.Float(allow_none=True)
    longitude = fields.Float(allow_none=True)
    address = fields.Str(allow_none=True)
    # --- Fields for DUMPING data (API output) ---
    status = EnumField(GrievanceStatus, by_value=True, dump_only=True)
    priority = EnumField(Priority, by_value=True, allow_none=True, dump_default=Priority.MEDIUM.value)
    rejection_reason = fields.Str(allow_none=True, dump_only=True)
    resolved_at = fields.DateTime(allow_none=True, dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    # Nested objects for richer API output
    citizen = fields.Nested(UserSchema(only=("id", "name")), dump_only=True, dump_default={'id': 0, 'name': 'Unknown User'})
    subject = fields.Nested('MasterSubjectsSchema', dump_only=True)
    area = fields.Nested('MasterAreasSchema', dump_only=True)
    category = fields.Nested('MasterCategoriesSchema', dump_only=True)  # New nested field
    assignee = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)
    assigner = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)  # New: for assigned_by
    attachments = fields.Nested('GrievanceAttachmentSchema', many=True, dump_only=True)
    comments = fields.Nested('GrievanceCommentSchema', many=True, dump_only=True)

    @validates('citizen')
    def validate_citizen(self, value):
        if value is None:
            return {'id': 0, 'name': 'Unknown User'}

class GrievanceAttachmentSchema(Schema):
    id = fields.Int(dump_only=True)
    grievance_id = fields.Int(required=True)
    file_path = fields.Str(dump_only=True)
    file_type = fields.Str(dump_only=True)
    file_size = fields.Int(dump_only=True)  # Already included
    uploaded_at = fields.DateTime(dump_only=True)


class CommentAttachmentSchema(Schema):
    id = fields.Int(dump_only=True)
    comment_id = fields.Int(required=True)
    file_path = fields.Str(dump_only=True)
    file_type = fields.Str(dump_only=True)
    file_size = fields.Int(dump_only=True)
    uploaded_at = fields.DateTime(dump_only=True)



class GrievanceCommentSchema(Schema):
    id = fields.Int(dump_only=True)
    grievance_id = fields.Int(required=True)
    user_id = fields.Int(dump_only=True)
    comment_text = fields.Str(required=True)
    created_at = fields.DateTime(dump_only=True)
    is_public = fields.Boolean(dump_only=True)  # New field
    attachments = fields.Nested(CommentAttachmentSchema, many=True, dump_only=True)
    user = fields.Nested(UserSchema(only=("name",)), dump_only=True)

class WorkproofSchema(Schema):
    id = fields.Int(dump_only=True)
    grievance_id = fields.Int(required=True)
    uploaded_by = fields.Int(dump_only=True)
    file_path = fields.Str(dump_only=True)
    file_type = fields.Str(dump_only=True)  # New field
    file_size = fields.Int(dump_only=True)  # New field
    notes = fields.Str(allow_none=True)
    uploaded_at = fields.DateTime(dump_only=True)
    uploader = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)  # New nested field

class MasterSubjectsSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)
    category_id = fields.Int(allow_none=True)  # New field
    is_active = fields.Boolean(dump_only=True)  # New field
    category = fields.Nested('MasterCategoriesSchema', dump_only=True)  # New nested field

class MasterAreasSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)
    is_active = fields.Boolean(dump_only=True)  # New field

class MasterCategoriesSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)
    is_active = fields.Boolean(dump_only=True)

class AuditLogSchema(Schema):
    id = fields.Int(dump_only=True)
    action = fields.Str(required=True)
    action_type = fields.Str(allow_none=True)  # New field
    performed_by = fields.Int(required=True)
    grievance_id = fields.Int(allow_none=True)
    details = fields.Str(allow_none=True)  # New field
    timestamp = fields.DateTime(dump_only=True)
    performer = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)  # New nested field

class OtpTokenSchema(Schema):
    id = fields.Int(dump_only=True)
    phone_number = fields.Str(required=True)
    otp = fields.Str(required=True)
    expires_at = fields.DateTime(required=True)
    used = fields.Boolean(dump_only=True)  # New field
    created_at = fields.DateTime(dump_only=True)

class NotificationTokenSchema(Schema):
    id = fields.Int(dump_only=True)
    user_id = fields.Int(required=True)
    fcm_token = fields.Str(required=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)  # New field
    is_active = fields.Boolean(dump_only=True)  # New field
    user = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)  # New nested field

class MasterConfigSchema(Schema):
    id = fields.Int(dump_only=True)
    key = fields.Str(required=True)
    value = fields.Str(required=True)
    description = fields.Str(allow_none=True)  # New field
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

class AnnouncementSchema(Schema):
    id = fields.Int(dump_only=True)
    title = fields.Str(required=True)
    message = fields.Str(required=True)
    type = fields.Str(required=True, validate=validate.OneOf(["general", "emergency"]))
    created_at = fields.DateTime(dump_only=True)
    expires_at = fields.DateTime(allow_none=True)  # New field
    target_role = fields.Str(allow_none=True, validate=validate.OneOf([r.value for r in Role]))
    is_active = fields.Boolean()  # New field
    @validates("target_role")
    def validate_role(self, value):
        if value is None:
            return  # allow nulls
        allowed = ["CITIZEN", "MEMBER_HEAD", "FIELD_STAFF", "ADMIN"]
        if value.upper() not in allowed:
            raise ValidationError(f"Invalid target_role. Must be one of {allowed}")

class UserPreferenceSchema(Schema):
    id = fields.Int(dump_only=True)
    user_id = fields.Int(required=True)
    notifications_enabled = fields.Boolean(dump_default=True)
    language = fields.Str(dump_default='en', validate=validate.OneOf(['en', 'mr', 'hi']))
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    user = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\__init__.py ---
# app/__init__.py

from flask import Flask, send_from_directory
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_mail import Mail
from .config import Config
from flask_cors import CORS
from .extensions import oauth

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
mail = Mail()
import logging
# oauth is defined in extensions.py

def create_app():
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(__name__)
    app = Flask(__name__)
    
    app.config.from_object(Config)

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    mail.init_app(app)
    oauth.init_app(app)
    cors_origins = ["http://localhost:*", "http://127.0.0.1:*", "http://localhost:5500", "http://127.0.0.1:5500", "https://pcmcapp.onrender.com"]
    CORS(app, resources={r"/*": {
        "origins": cors_origins,
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Authorization", "Content-Type"],
        "expose_headers": ["*"],
        "supports_credentials": True
    }})
    logger.debug(f"CORS configured for origins: {', '.join(cors_origins)}")
    # Register Google OAuth client
    oauth.register(
        name='google',
        client_id=app.config.get('GOOGLE_CLIENT_ID'),
        client_secret=app.config.get('GOOGLE_CLIENT_SECRET'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={'scope': 'openid email profile'}
    )

    # Create upload folder if not exists
    import os
    if not os.path.exists(app.config['UPLOAD_FOLDER']):
        os.makedirs(app.config['UPLOAD_FOLDER'])

    # Add a route to serve uploaded files
    @app.route('/uploads/<path:filename>')
    def uploaded_file(filename):
        return send_from_directory(app.config['UPLOAD_FOLDER'], filename, as_attachment=False)

    # Import and register blueprints
    from .routes.auth_routes import auth_bp
    from .routes.grievance_routes import grievance_bp
    from .routes.user_routes import user_bp
    from .routes.admin_routes import admin_bp
    from .routes.notification_routes import notification_bp
    from .routes.public import public_bp
    from .routes.settings_routes import settings_bp
    from .routes.field_routes import fieldStaff
    app.register_blueprint(fieldStaff)
    app.register_blueprint(public_bp)
    app.register_blueprint(notification_bp, url_prefix='/notifications')

    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(grievance_bp, url_prefix='/grievances')
    app.register_blueprint(user_bp, url_prefix='/users')
    app.register_blueprint(admin_bp, url_prefix='/admins')
    app.register_blueprint(settings_bp, url_prefix='/settings')
    return app

=== Folder: app\routes ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\admin_routes.py ---
# app/routes/admin_routes.py

from flask import Blueprint, request, jsonify
from ..utils.auth_utils import admin_required
from ..utils.kpi_utils import calculate_resolution_rate, calculate_pending_aging, calculate_sla_compliance
from ..models import AuditLog,MasterConfig, MasterSubjects, MasterAreas, Grievance, User, Role, Announcement, NotificationToken
from ..services.report_service import generate_report,get_staff_performance, get_location_reports
from ..services.notification_service import send_notification
from ..services.report_service import get_citizen_history
from ..services.report_service import escalate_grievance
from ..services.report_service import get_advanced_kpis
from datetime import datetime
from ..schemas import GrievanceSchema, UserSchema, AnnouncementSchema
from flask import Response
from ..schemas import AuditLogSchema, MasterSubjectsSchema, MasterAreasSchema
from .. import db
from ..services.grievance_service import reassign_grievance
from ..services.user_service import add_update_user
from flask_cors import cross_origin
from flask_jwt_extended import jwt_required
import logging
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.exc import IntegrityError
from datetime import datetime, timezone
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

admin_bp = Blueprint('admin', __name__)

@admin_bp.route('/dashboard', methods=['GET'])
@admin_required
def dashboard(user):
    kpis = {
        'resolution_rate': calculate_resolution_rate(),
        'pending_aging': calculate_pending_aging(),
        'sla_compliance': calculate_sla_compliance()
    }
    return jsonify(kpis), 200

@admin_bp.route('/users/<int:id>', methods=['DELETE'])
@admin_required
def delete_user(user, id):
    """Delete a specific user by ID."""
    try:
        user_to_delete = User.query.get(id)
        if not user_to_delete:
            return jsonify({"msg": "User not found"}), 404
        db.session.delete(user_to_delete)
        db.session.commit()
        return jsonify({"msg": "User deleted successfully"}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({"msg": "Failed to delete user", "error": str(e)}), 500





@admin_bp.route('/subjects', methods=['POST'])
@admin_required
def manage_subjects(user):
    data = request.json
    print(f"Received data: {data}")
    schema = MasterSubjectsSchema()
    errors = schema.validate(data)
    if errors:
        print(f"Validation errors: {errors}")
        return jsonify(errors), 400
    try:
        subject = MasterSubjects(**data)
        db.session.add(subject)
        db.session.commit()
        print(f"Subject {subject.name} added successfully")
        return schema.dump(subject), 201
    except Exception as e:
        db.session.rollback()
        print(f"Database error: {e}")
        return jsonify({"error": "Failed to save subject"}), 500


@admin_bp.route('/subjects/<int:id>', methods=['PUT'])
@admin_required
def update_subject(user, id):
    data = request.json
    print(f"Update request for subject {id}: {data}")

    schema = MasterSubjectsSchema()
    errors = schema.validate(data, partial=True)  # allow partial updates
    if errors:
        return jsonify(errors), 400

    try:
        subject = db.session.get(MasterSubjects, id)
        if not subject:
            return jsonify({"error": "Subject not found"}), 404

        # Update fields
        subject.name = data.get("name", subject.name)
        subject.description = data.get("description", subject.description)

        db.session.commit()
        print(f"Subject {subject.id} updated successfully")
        return schema.dump(subject), 200
    except Exception as e:
        db.session.rollback()
        print(f"Database error: {e}")
        return jsonify({"error": "Failed to update subject"}), 500

@admin_bp.route('/subjects/<int:id>', methods=['DELETE'])
@admin_required
def delete_subject(user, id):
    """Delete a specific subject by ID."""
    try:
        subject_to_delete = MasterSubjects.query.get(id)
        if not subject_to_delete:
            return jsonify({"msg": "Subject not found"}), 404
        
        db.session.delete(subject_to_delete)
        db.session.commit()
        return jsonify({"msg": "Subject deleted successfully"}), 200
    except Exception as e:
        db.session.rollback()
        # Check for foreign key constraint error
        error_info = str(e).lower()
        if 'foreign key constraint' in error_info or 'violates foreign key' in error_info:
            return jsonify({"msg": "Cannot delete subject. It is in use by existing grievances."}), 409
        
        return jsonify({"msg": "Failed to delete subject", "error": str(e)}), 500


@admin_bp.route('/areas', methods=['POST'])
@admin_required
def manage_areas(user):
    data = request.json
    schema = MasterAreasSchema()
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    area = MasterAreas(**data)
    db.session.add(area)
    db.session.commit()
    return schema.dump(area), 201

@admin_bp.route('/areas/<int:id>', methods=['PUT'])
@admin_required
def update_area(user, id):
    data = request.json
    schema = MasterAreasSchema(partial=True)
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    
    area = db.session.get(MasterAreas, id)
    if not area:
        return jsonify({"error": "Area not found"}), 404
    
    area.name = data.get('name', area.name)
    area.description = data.get('description', area.description)
    db.session.commit()
    
    return MasterAreasSchema().dump(area), 200

@admin_bp.route('/areas/<int:id>', methods=['DELETE'])
@admin_required
def delete_area(user, id):
    area_to_delete = MasterAreas.query.get(id)
    if not area_to_delete:
        return jsonify({"msg": "Area not found"}), 404
    
    db.session.delete(area_to_delete)
    db.session.commit()
    return jsonify({"msg": "Area deleted successfully"}), 200

@admin_bp.route('/reassign/<int:grievance_id>', methods=['POST'])
@admin_required
def reassign_grievance(user, grievance_id):
    """
    Reassign a grievance to a new field staff member.
    """
    try:
        data = request.get_json()
        # The frontend code is sending 'assigned_to', not 'assignee_id'.
        new_assignee_id = data.get('assigned_to')
        if not new_assignee_id:
            return jsonify({"success": False, "message": "Assignee ID is required"}), 400
        
        grievance = Grievance.query.get(grievance_id)
        if not grievance:
            return jsonify({"success": False, "message": "Grievance not found"}), 404
        
        assignee = User.query.get(new_assignee_id)
        if not assignee or assignee.role != Role.FIELD_STAFF:
            return jsonify({"success": False, "message": "Invalid assignee"}), 400
        
        grievance.assigned_to = new_assignee_id
        grievance.assigned_by = user.id
        grievance.updated_at = datetime.now(timezone.utc)
        
        db.session.commit()
        
        # Notify the new assignee
        from ..services.notification_service import send_notification
        send_notification(
            assignee.email,
            'Grievance Assigned',
            f'You have been assigned grievance #{grievance_id}'
        )
        
        return jsonify({"success": True, "message": "Grievance reassigned successfully"})
    except Exception as e:
        db.session.rollback()
        return jsonify({"success": False, "message": str(e)}), 500

@admin_bp.route('/audit-logs', methods=['GET', 'OPTIONS'])
def audit_logs():
    if request.method == 'OPTIONS':
        return '', 200  # Allow preflight without JWT

    return _audit_logs_protected()


@jwt_required()
@admin_required
def _audit_logs_protected(user):
    logs = AuditLog.query.all()
    schema = AuditLogSchema(many=True)
    return jsonify(schema.dump(logs)), 200


# Add to existing admin_bp

@admin_bp.route('/kpis/advanced', methods=['GET'])
@admin_required
def advanced_kpis(user):
    return jsonify(get_advanced_kpis()), 200

@admin_bp.route('/reports', methods=['GET'])
@admin_required
def reports(user):
    filter_type = request.args.get('filter_type', 'all')
    format = request.args.get('format', 'pdf')

    # Your existing function that generates report data
    report_data = generate_report(filter_type, format)

    if format == 'pdf':
        # report_data should be bytes for PDF
        return Response(
            report_data,
            mimetype='application/pdf',
            headers={"Content-Disposition": "attachment; filename=report.pdf"}
        )

    elif format == 'csv':
        # report_data should be a string (CSV text)
        return Response(
            report_data,
            mimetype='text/csv',
            headers={"Content-Disposition": "attachment; filename=report.csv"}
        )

    elif format == 'excel':
        # report_data should be bytes (Excel file content)
        return Response(
            report_data,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            headers={"Content-Disposition": "attachment; filename=report.xlsx"}
        )

    else:
        return {"error": "Invalid format. Supported: pdf, csv, excel"}, 400
@admin_bp.route('/users/<int:id>/history', methods=['GET'])
@admin_required
def citizen_history(user, id):
    history = get_citizen_history(id)
    schema = GrievanceSchema(many=True)
    return jsonify(schema.dump(history)), 200

@admin_bp.route('/grievances/all', methods=['GET'])
@admin_required
def get_all_grievances(user):
    """
    Fetch all grievances with optional filters.
    """
    try:
        from ..models import Grievance
        status = request.args.get('status')
        priority = request.args.get('priority')
        area_id = request.args.get('area_id', type=int)
        subject_id = request.args.get('subject_id', type=int)
        
        query = Grievance.query
        if status:
            query = query.filter_by(status=status)
        if priority:
            query = query.filter_by(priority=priority)
        if area_id:
            query = query.filter_by(area_id=area_id)
        if subject_id:
            query = query.filter_by(subject_id=subject_id)
        
        grievances = query.order_by(Grievance.created_at.desc()).all()

        return jsonify([g.to_dict() for g in grievances])
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500



@admin_bp.route('/grievances/<int:id>/escalate', methods=['POST'])
@admin_required
def escalate(user, id):
    try:
        data = request.json or {}
        print("Incoming escalate request:", data)

        new_assignee_id = data.get('assignee_id')

        # Escalate grievance
        result = escalate_grievance(
            grievance_id=id,
            escalated_by=user.id,   # always take from current logged-in user
            new_assignee_id=new_assignee_id
        )

        status_code = 200 if result.get("success") else 400
        return jsonify(result), status_code

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500



@admin_bp.route('/configs', methods=['GET', 'POST', 'OPTIONS'])
def manage_configs():
    if request.method == 'OPTIONS':
        # Respond to preflight without JWT
        return jsonify({}), 200

    return _manage_configs_protected()


@jwt_required()
@admin_required
def _manage_configs_protected(user):
    if request.method == 'POST':
        data = request.json

        # Check if config already exists (upsert)
        config = MasterConfig.query.filter_by(key=data['key']).first()
        if config:
            # Update existing
            config.value = data['value']
            config.updated_at = datetime.now(timezone.utc)
            if 'description' in data:
                config.description = data['description']
        else:
            # Insert new
            config = MasterConfig(
                key=data['key'],
                value=data['value'],
                description=data.get('description')
            )
            db.session.add(config)

        db.session.commit()

    # Always return configs
    configs = MasterConfig.query.all()
    return jsonify([
        {
            'id': c.id,
            'key': c.key,
            'value': c.value,
            'description': c.description,
            'created_at': c.created_at,
            'updated_at': c.updated_at,
        }
        for c in configs
    ]), 200

# In app/routes/admin_routes.py
@admin_bp.route('/configs/<string:key>', methods=['PUT'])
@admin_required
def update_config( key):
    data = request.json
    config = MasterConfig.query.filter_by(key=key).first()
    if not config:
        return jsonify({"error": "Config not found"}), 404
    config.value = data.get('value')
    config.updated_at = datetime.now(timezone.utc)
    db.session.commit()
    return jsonify({'key': config.key, 'value': config.value}), 200

@admin_bp.route('/users/history', methods=['GET'])
@admin_required
def all_users_history(user):
    users = User.query.all()
    result = []
    grievance_schema = GrievanceSchema(many=True)
    for u in users:
        history = get_citizen_history(u.id)
        result.append({
            "user": {
                "id": u.id,
                "name": u.name,
                "email": u.email,
                "role": u.role.value if u.role else None
            },
            "grievances": grievance_schema.dump(history)
        })
    return jsonify(result), 200

@admin_bp.route('/subjects', methods=['GET'])
@admin_required
def list_subjects(user):
    subjects = MasterSubjects.query.all()
    schema = MasterSubjectsSchema(many=True)
    return jsonify(schema.dump(subjects)), 200

@admin_bp.route('/areas', methods=['GET'])
@admin_required
def list_areas(user):
    areas = MasterAreas.query.all()
    schema = MasterAreasSchema(many=True)
    return jsonify(schema.dump(areas)), 200

@admin_bp.route('/users', methods=['GET'])
@admin_required
def list_users(user):
    users = User.query.all()
    schema = UserSchema(many=True, exclude=['password'])  # Exclude sensitive fields
    return jsonify(schema.dump(users)), 200

@admin_bp.route('/users/<int:id>', methods=['PUT'])
@admin_required
def update_user(user, id):
    try:
        data = request.json
        print(f"Received data: {data}")
        if not data:
            return jsonify({"msg": "No data provided"}), 400
        
        result = add_update_user(data, user_id=id)

        return jsonify(result), 200
    except ValueError as e:
        return jsonify({"msg": str(e)}), 400
    except IntegrityError as e:
        return jsonify({"msg": "Database integrity error, possible duplicate data.", "error": str(e)}), 409
    except SQLAlchemyError as e:
        print(f"Database error: {str(e)}")
        
        return jsonify({"msg": "Database error occurred", "error": str(e)}), 500
    except AttributeError as e:
        print(f"Attribute error: {str(e)}")
       
        return jsonify({"msg": "Invalid user attribute", "error": str(e)}), 400
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        
        return jsonify({
            "msg": "Failed to update user",
            "error": str(e) or "Unknown error"
        }), 500



@admin_bp.route('/users', methods=['POST'])
@admin_required
def create_user(user):
    try:
        data = request.json
        print(f"Received data for new user: {data}")
        if not data:
            return jsonify({"msg": "No data provided"}), 400

        result = add_update_user(data)  # no user_id → create

        return jsonify(result), 201
    except ValueError as e:
        return jsonify({"msg": str(e)}), 400
    except IntegrityError as e:
        return jsonify({"msg": "Database integrity error, possible duplicate data.", "error": str(e)}), 409
    except SQLAlchemyError as e:
        print(f"Database error: {str(e)}")
        return jsonify({"msg": "Database error occurred", "error": str(e)}), 500
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return jsonify({"msg": "Failed to create user", "error": str(e)}), 500






@admin_bp.route('/reports/staff-performance', methods=['GET'])
@admin_required
def staff_performance(user):
    return jsonify(get_staff_performance()), 200

@admin_bp.route('/reports/location', methods=['GET'])
@admin_required
def location_reports(user):
    return jsonify(get_location_reports()), 200

@admin_bp.route('/announcements', methods=['POST'])
@admin_required
def create_announcement(user):
    data = request.json
    print("DEBUG incoming:", data)
    schema = AnnouncementSchema()
    errors = schema.validate(data)
    print("DEBUG errors:", errors)
    if errors:
        return jsonify(errors), 400
    data["target_role"] = data["target_role"].upper() if data.get("target_role") else None
    if data.get("expires_at"):
        try:
            # Handle ISO 8601 format from frontend
            data["expires_at"] = datetime.fromisoformat(data["expires_at"].replace("Z", ""))
        except ValueError:
            return jsonify({"error": "Invalid date format for expires_at"}), 400
    announcement = Announcement(**data)
    db.session.add(announcement)
    db.session.commit()

    # Broadcast via email/FCM
    users = User.query.all()
    for u in users:
        if not u.email:  # skip users without email
            continue
        token = NotificationToken.query.filter_by(user_id=u.id).first()
        send_notification(
            to=u.email,
            subject=f"{data['type'].capitalize()} Announcement",
            body=data['message'],
            fcm_token=token.fcm_token if token else None
        )
    return schema.dump(announcement), 201

@admin_bp.route('/announcements', methods=['GET'])
def get_announcements():
    # This could be moved to a public blueprint if needed, but for now under admin
    # Optionally filter by active, non-expired, etc.
    now = datetime.now(timezone.utc)
    announcements = Announcement.query.filter(
        Announcement.is_active == True,
        db.or_(Announcement.expires_at > now, Announcement.expires_at == None)
    ).order_by(Announcement.created_at.desc()).all()
    return AnnouncementSchema(many=True).dump(announcements), 200

@admin_bp.route('/reports/kpis/advanced', methods=['GET', 'OPTIONS'])
def get_advanced_kpis_route():
    # Skip authentication for OPTIONS preflight requests
    if request.method == "OPTIONS":
        return '', 200

    # For actual GET requests, enforce JWT + admin
    @jwt_required()
    @admin_required
    def actual_route(user):
        time_period = request.args.get('time_period', 'all')
        try:
            kpis = get_advanced_kpis(time_period)
            return jsonify(kpis), 200
        except ValueError as ve:
            return jsonify({"error": str(ve)}), 400
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    return actual_route()

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\auth_routes.py ---
# app/routes/auth_routes.py

# app/routes/auth_routes.py

from flask import Blueprint, request, jsonify, redirect, url_for, session, current_app
from flask_jwt_extended import create_access_token, create_refresh_token, get_jwt_identity, jwt_required
from requests_oauthlib.oauth2_session import OAuth2Session
import requests
from ..models import User, Role
from .. import db
from ..schemas import UserSchema
from werkzeug.security import check_password_hash
from ..services.otp_service import send_otp, verify_otp
from ..utils.file_utils import allowed_file
from werkzeug.utils import secure_filename
import os
from sqlalchemy.exc import IntegrityError

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.json
    email = data.get('email')
    name = data.get('name')
    password = data.get('password')
    voter_id = data.get('voter_id')

    if not email or not name or not password:
        return jsonify({"msg": "Missing required fields: name, email, password"}), 400

    if User.query.filter_by(email=email).first():
        return jsonify({"msg": "Email already exists"}), 400

    if voter_id and User.query.filter_by(voter_id=voter_id).first():
        return jsonify({"msg": "Voter ID already exists"}), 400
    
    user = User(
        name=name,
        email=email,
        phone_number=data.get('phone_number'),
        address=data.get('address'),
        voter_id=voter_id,
        role=Role.CITIZEN,  # Default to CITIZEN for registration
    )
    user.set_password(password)
    db.session.add(user)
    db.session.commit()

    access_token = create_access_token(identity=str(user.id))
    return jsonify({"access_token": access_token}), 200

@auth_bp.route('/login', methods=['POST'])
def password_login():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    user = User.query.filter_by(email=email).first()
    if not user or not user.check_password(password):
        return jsonify({"msg": "Invalid email or password"}), 401

    access_token = create_access_token(identity=str(user.id))
    return jsonify({"access_token": access_token}), 200

# app/routes/auth_routes.py
@auth_bp.route('/refresh', methods=['POST'])
@jwt_required(refresh=True)
def refresh():
    current_user_id = get_jwt_identity()
    new_access_token = create_access_token(identity=current_user_id)
    new_refresh_token = create_refresh_token(identity=current_user_id)
    return jsonify({
        "access_token": new_access_token,
        "refresh_token": new_refresh_token
    }), 200



@auth_bp.route('/google/login')
def google_login():
    """
    Step 1: Redirects the user to Google's authentication page.
    """
    if not current_app.config.get('GOOGLE_CLIENT_ID') or not current_app.config.get('GOOGLE_CLIENT_SECRET'):
        return jsonify({"msg": "Google OAuth is not configured on the server."}), 500

    try:
        google_discovery_doc = requests.get(current_app.config['GOOGLE_DISCOVERY_URL']).json()
        authorization_endpoint = google_discovery_doc.get("authorization_endpoint")
    except requests.exceptions.RequestException as e:
        return jsonify({"msg": "Could not connect to Google's discovery service.", "error": str(e)}), 500

    oauth_session = OAuth2Session(
        client_id=current_app.config['GOOGLE_CLIENT_ID'],
        redirect_uri=url_for('auth.google_callback', _external=True),
        scope=["openid", "email", "profile"]
    )

    authorization_url, state = oauth_session.authorization_url(authorization_endpoint)
    session['oauth_state'] = state
    return redirect(authorization_url)

@auth_bp.route('/google/callback')
def google_callback():
    if not current_app.config.get('GOOGLE_CLIENT_ID') or not current_app.config.get('GOOGLE_CLIENT_SECRET'):
        return jsonify({"msg": "Google OAuth is not configured on the server."}), 500

    try:
        google_discovery_doc = requests.get(current_app.config['GOOGLE_DISCOVERY_URL']).json()
        token_endpoint = google_discovery_doc.get("token_endpoint")
        userinfo_endpoint = google_discovery_doc.get("userinfo_endpoint")
    except requests.exceptions.RequestException as e:
        return jsonify({"msg": "Could not connect to Google's discovery service.", "error": str(e)}), 500

    oauth_session = OAuth2Session(
        client_id=current_app.config['GOOGLE_CLIENT_ID'],
        state=session.get('oauth_state'),
        redirect_uri=url_for('auth.google_callback', _external=True)
    )

    try:
        token = oauth_session.fetch_token(
            token_endpoint,
            client_secret=current_app.config['GOOGLE_CLIENT_SECRET'],
            authorization_response=request.url
        )
    except Exception as e:
        return jsonify({"msg": "Failed to fetch token from Google.", "error": str(e)}), 400

    user_info = oauth_session.get(userinfo_endpoint).json()
    email, name = user_info.get('email'), user_info.get('name')

    user = User.query.filter_by(email=email).first()
    if not user:
        user = User(name=name, email=email, role=Role.CITIZEN)
        db.session.add(user)
        db.session.commit()

    access_token = create_access_token(identity=str(user.id))
    frontend_callback_url = f"http://localhost:5500/login/callback?access_token={access_token}"
    return redirect(frontend_callback_url)

@auth_bp.route('/logout', methods=['POST'])
def logout():
    return jsonify({"msg": "Logout successful"}), 200

@auth_bp.route('/me', methods=['GET'])
@jwt_required()
def get_current_user():
    user_id = get_jwt_identity()
    user = User.query.get(int(user_id))   # convert back to int
    if not user:
        return jsonify({"msg": "User not found"}), 404
    schema = UserSchema()
    return jsonify(schema.dump(user)), 200


@auth_bp.route('/me', methods=['PUT'])
@jwt_required()
def update_current_user():
    current_user_id = get_jwt_identity()
    user = User.query.get(current_user_id)
    if not user:
        return jsonify({"msg": "User not found"}), 404

    # Handle form data (text fields)
    data = request.form
    if 'name' in data:
        user.name = data['name']
    if 'email' in data:
        if User.query.filter(User.email == data['email'], User.id != current_user_id).first():
            return jsonify({"msg": "Email already exists"}), 400
        user.email = data['email']
    if 'password' in data and data['password']:
        user.set_password(data['password'])
    if 'address' in data:
        user.address = data['address']

    # Handle file upload for profile_picture
    if 'profile_picture' in request.files:
        file = request.files['profile_picture']
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            user_dir = os.path.join(current_app.config['UPLOAD_FOLDER'], f'user_{user.id}')
            os.makedirs(user_dir, exist_ok=True)
            file_path = os.path.join(user_dir, filename)
            file.save(file_path)
            # Store relative path for easy serving (e.g., via /uploads/<path>)
            user.profile_picture = f'user_{user.id}/{filename}'
        else:
            return jsonify({"msg": "Invalid file type"}), 400

    try:
        db.session.commit()
        return jsonify(UserSchema().dump(user))
    except IntegrityError:
        db.session.rollback()
        return jsonify({"msg": "Update failed due to duplicate data"}), 400
    except Exception as e:
        db.session.rollback()
        return jsonify({"msg": f"Update failed: {str(e)}"}), 500






@auth_bp.route('/otp/send', methods=['POST'])
def send_otp():
    data = request.json
    phone_number = data.get('phone_number')
    if not phone_number:
        return jsonify({"msg": "Phone number required"}), 400
    return jsonify(send_otp(phone_number)), 200

@auth_bp.route('/otp/verify', methods=['POST'])
def verify_otp_route():
    data = request.json
    phone_number = data.get('phone_number')
    otp = data.get('otp')

    if verify_otp(phone_number, otp):
        user = User.query.filter_by(phone_number=phone_number).first()
        if not user:
            # ✅ Auto-register new user if first OTP login
            user = User(phone_number=phone_number, role=Role.CITIZEN, name="Guest User")
            db.session.add(user)
            db.session.commit()

        access_token = create_access_token(identity=str(user.id))
        refresh_token = create_refresh_token(identity=str(user.id))
        return jsonify({"access_token": access_token, "refresh_token": refresh_token}), 200
    
    return jsonify({"msg": "Invalid or expired OTP"}), 401

@auth_bp.route('/guest-login', methods=['POST'])
def guest_login():
    """
    Allows users to login as Guest with limited access (read-only).
    """
    guest_user = User(name="Guest User", role=Role.CITIZEN)
    db.session.add(guest_user)
    db.session.commit()

    access_token = create_access_token(identity=str(guest_user.id))
    refresh_token = create_refresh_token(identity=str(guest_user.id))
    return jsonify({
        "access_token": access_token,
        "refresh_token": refresh_token,
        "msg": "Logged in as Guest"
    }), 200

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\field_routes.py ---
# app/routes/user_routes.py
from flask import Blueprint, request, jsonify
from app.models import User, Role
from app import db

fieldStaff = Blueprint("fieldStaff", __name__, url_prefix="/fieldStaff")

@fieldStaff.route("/fieldStaff", methods=["GET"])
def get_users():
    role = request.args.get("role")
    query = User.query

    if role:
        try:
            role_enum = Role(role)  # validate role string
            query = query.filter_by(role=role_enum)
        except ValueError:
            return jsonify({"error": "Invalid role"}), 400

    users = query.all()
    return jsonify([
        {
            "id": u.id,
            "name": u.name,
            "email": u.email,
            "phone_number": u.phone_number,
            "role": u.role.value,
        }
        for u in users
    ])

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\grievance_routes.py ---
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from ..utils.auth_utils import citizen_required, jwt_required_with_role, admin_required, member_head_required, field_staff_required, citizen_or_admin_required, field_staff_or_admin_required
from ..models import Grievance, GrievanceStatus, Role, User, GrievanceComment, MasterConfig
from ..schemas import GrievanceSchema, GrievanceCommentSchema
from ..services.grievance_service import (
    submit_grievance, get_my_grievances, get_grievance_details,
    add_comment, confirm_closure, get_rejection_reason,
    get_new_grievances, accept_grievance, reject_grievance,
    get_assigned_grievances, update_status, upload_workproof,
    escalate_grievance, save_workproof_record
)
from ..services.notification_service import send_notification
from .. import db
from ..services.grievance_service import log_audit
from datetime import datetime, timezone

grievance_bp = Blueprint('grievances', __name__)

@grievance_bp.route('/', methods=['POST'])
@citizen_required
def create_grievance(user):
    current_app.logger.info(f"Request Content-Type: {request.content_type}")
    current_app.logger.info(f"Form data keys: {list(request.form.keys())}")
    current_app.logger.info(f"Files keys: {list(request.files.keys())}")
    try:
        if request.content_type.startswith('multipart/form-data'):
            data = request.form.to_dict()
        else:
            data = request.json

        # Collect all files uploaded under the 'attachments' key
        files = request.files.getlist('attachments')  # This gets all files with the same key
        
        current_app.logger.info(f"Collected {len(files)} files for upload")
        
        # Set default priority if not provided
        if 'priority' not in data or not data['priority']:
            default_priority = MasterConfig.query.filter_by(key='DEFAULT_PRIORITY').first()
            data['priority'] = default_priority.value if default_priority else 'medium'

        # Ensure lat/lng passed as float
        if "latitude" in data and data["latitude"]:
            data["latitude"] = float(data["latitude"])
        if "longitude" in data and data["longitude"]:
            data["longitude"] = float(data["longitude"])

        result = submit_grievance(user.id, data, files)
        log_audit(f"Grievance created by user {user.id}", user.id, result.get('id'))
        return jsonify(result), 201
    except Exception as e:
        current_app.logger.error(f"Error creating grievance: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/mine', methods=['GET'])
@citizen_or_admin_required
def my_grievances(user):
    current_app.logger.info(f"Fetching grievances for user {user.id} with role {user.role}")
    try:
        if user.role == Role.ADMIN:
            grievances = Grievance.query.order_by(Grievance.created_at.desc()).all()  # Admins see all grievances
        else:
            grievances = Grievance.query.filter_by(citizen_id=user.id).order_by(Grievance.created_at.desc()).all()  # Citizens see only their own
            print(f"Fetched {[g.to_dict() for g in grievances]} grievances for user {user.id}")
        return jsonify([grievance.to_dict() for grievance in grievances]), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching grievances for user {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>', methods=['GET'])
@jwt_required_with_role([Role.CITIZEN, Role.MEMBER_HEAD, Role.FIELD_STAFF, Role.ADMIN])
def get_grievance(user, id):
    current_app.logger.info(f"Fetching grievance ID {id} for user ID {user.id} with role {user.role}")
    grievance = db.session.get(Grievance, id)
    if not grievance:
        current_app.logger.error(f"Grievance ID {id} not found")
        return jsonify({"msg": "Grievance not found"}), 404
    schema = GrievanceSchema()
    current_app.logger.info(f"Grievance found: {schema.dump(grievance)}")
    return jsonify(schema.dump(grievance)), 200

@grievance_bp.route('/<int:id>/comments', methods=['POST'])
@jwt_required_with_role([Role.CITIZEN, Role.MEMBER_HEAD, Role.FIELD_STAFF, Role.ADMIN])
def add_grievance_comment(user, id):
    try:
        # Handle multipart/form-data
        if request.content_type.startswith('multipart/form-data'):
            data = request.form.to_dict()
            files = request.files.getlist('attachments')  # Support multiple files, like grievances
        else:
            data = request.get_json()
            files = []  # No files if JSON

        comment_text = data.get('comment_text')
        if not comment_text:
            return jsonify({"msg": "Comment text is required"}), 400
        
        # Call updated service with files
        result = add_comment(id, user.id, comment_text, files)
        log_audit(f"Comment added to grievance {id}", user.id, id)
        return jsonify(result), 201
    except Exception as e:
        current_app.logger.error(f"Error adding comment to grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/close', methods=['POST'])
@citizen_required
def close_grievance(user, id):
    try:
        result = confirm_closure(id, user.id)
        log_audit(f"Grievance {id} closed by user {user.id}", user.id, id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error closing grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/rejection', methods=['GET'])
@citizen_required
def rejection_reason(user, id):
    try:
        reason = get_rejection_reason(id, user.id)
        return jsonify({"rejection_reason": reason}), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching rejection reason for grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/all', methods=['GET'])
@member_head_required
def new_grievances(user):
    try:
        result = get_new_grievances() # This fetches all grievances, ordered by creation date
        current_app.logger.info(f"New grievances for department: {len(result)} grievances found.")
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching new grievances for department : {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/accept', methods=['POST'])
@member_head_required
def accept(user, id):
    try:
        data = request.get_json()
        result = accept_grievance(id, user.id, data)
        log_audit(f"Grievance {id} accepted by user {user.id}", user.id, id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error accepting grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/reject', methods=['POST'])
@member_head_required
def reject(user, id):
    try:
        data = request.get_json() or {}
        current_app.logger.info(f"Rejecting grievance {id} with data: {data}")
        reason = data.get('reason')
        current_app.logger.info(f"Rejection reason: {reason}")
        if not reason:
            current_app.logger.warning("Rejection reason is required")
            return jsonify({"msg": "Rejection reason is required"}), 400
        result = reject_grievance(id, user.id, reason)
        current_app.logger.info(f"Result of rejection: {result}")
        log_audit(f"Grievance {id} rejected by user {user.id}", user.id, id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error rejecting grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/assigned', methods=['GET'])
@field_staff_required
def assigned_grievances(user):
    try:
        result = get_assigned_grievances(user.id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching assigned grievances for user {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400





# app/routes/grievance_routes.py
@grievance_bp.route('/assigned/<int:user_id>', methods=['GET'])
@jwt_required()
@field_staff_required
def get_assigned_grievances_by_user(user, user_id):
    """
    Retrieve grievances assigned to a specific user (admin only).
    """
    try:
        # Verify the target user exists
        target_user = User.query.get(user_id)
        if not target_user:
            return jsonify({"msg": "User not found"}), 404

        # Fetch grievances assigned to the specified user
        grievances = Grievance.query.filter_by(assigned_to=user_id).all()
        if not grievances:
            return jsonify({"msg": "No grievances assigned to this user"}), 404

        return jsonify([grievance.to_dict() for grievance in grievances]), 200
    except Exception as e:
        return jsonify({"msg": f"Error fetching assigned grievances: {str(e)}"}), 500




@grievance_bp.route('/<int:id>/status', methods=['PUT','POST'])
@field_staff_or_admin_required
def update_grievance_status(user, id):
    data = request.json
    new_status_str = data.get('status')
    current_app.logger.info(f"Updating status for grievance {id} to {new_status_str} by user {user.id}")
    try:
        current_app.logger.info("Fetching grievance...")
        grievance = db.session.get(Grievance, id)
        if not grievance:
            return jsonify({"error": "Grievance not found"}), 404
        current_app.logger.info(f"Grievance found: {grievance}")
        # Check if the user is the assigned staff OR an ADMIN
        if grievance.assigned_to != user.id and user.role not in [Role.ADMIN, Role.MEMBER_HEAD]:
            return jsonify({"error": "Not authorized to update this grievance"}), 403
        
        current_app.logger.info("Updating grievance status...")
        old_status = grievance.status
        grievance.status = GrievanceStatus[new_status_str.upper()]
        if grievance.status == GrievanceStatus.RESOLVED:
            grievance.resolved_at = datetime.now(timezone.utc)
        db.session.commit()
        print(f"Status updated from {old_status} to {grievance.status}")
        log_audit(f'Status updated from {old_status} to {grievance.status}', user.id, id)
        send_notification(
            grievance.citizen.email,
            'Status Updated',
            f'Your grievance #{id} status is now {new_status_str}.'
        )
        schema = GrievanceSchema()
        return jsonify(schema.dump(grievance)), 200
    except ValueError as e:
        current_app.logger.error(f"Invalid status value for grievance {id}: {str(e)}")
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Failed to update status for grievance {id}: {str(e)}")
        return jsonify({"error": f"Failed to update status: {str(e)}"}), 500

@grievance_bp.route('/<int:id>/workproof', methods=['POST'])
@field_staff_required
def upload_grievance_workproof(user, id):
    try:
        file = request.files.get('file')
        if not file:
            return jsonify({"msg": "File is required"}), 400
        
        data = request.form
        result = save_workproof_record(id, user.id, file, data.get('notes'))
        
        log_audit(f"Workproof uploaded for grievance {id}", user.id, id)
        return jsonify(result), 201
    except Exception as e:
        current_app.logger.error(f"Error uploading workproof for grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/feedback', methods=['POST'])
@citizen_required
def submit_feedback(user, id):
    try:
        grievance = Grievance.query.get_or_404(id)
        if grievance.citizen_id != user.id or grievance.status != GrievanceStatus.RESOLVED:
            return jsonify({"msg": "Invalid operation: Grievance must be resolved and owned by user"}), 400
        data = request.get_json()
        rating = data.get('rating')
        if not rating or not isinstance(rating, int) or rating < 1 or rating > 5:
            return jsonify({"msg": "Valid rating (1-5) is required"}), 400
        grievance.feedback_rating = rating
        grievance.feedback_text = data.get('feedback_text')
        db.session.commit()
        log_audit(f"Feedback submitted for grievance {id}", user.id, id)
        return jsonify({"msg": "Feedback submitted successfully"}), 200
    except Exception as e:
        current_app.logger.error(f"Error submitting feedback for grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/admin/<int:id>', methods=['GET'])
@admin_required
def get_grievance_admin(user, id):
    try:
        grievance = Grievance.query.get_or_404(id)
        schema = GrievanceSchema()
        return jsonify(schema.dump(grievance)), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching grievance {id} for admin: {str(e)}")
        return jsonify({"msg": str(e)}), 404

@grievance_bp.route('/admin/grievances/all', methods=['GET'])
@admin_required
def get_all_grievances(user):
    try:
        grievances = Grievance.query.order_by(Grievance.created_at.desc()).all()

        schema = GrievanceSchema(many=True)
        log_audit(f"Admin {user.id} fetched all grievances", user.id, None)
        return jsonify(schema.dump(grievances)), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching all grievances for admin {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/reassign', methods=['PUT'])
@field_staff_or_admin_required
def reassign_grievance(user, id):
    try:
        print(f"Reassigning grievance {id} to user {user.id}")
        data = request.get_json()
        assignee_id = data.get('assignee_id')
        print(f"Assignee ID: {assignee_id}")
        if not assignee_id:
            print("Assignee ID is required")
            return jsonify({"msg": "Assignee ID is required"}), 400
        grievance = Grievance.query.get_or_404(id)
        assignee = User.query.get_or_404(assignee_id)
        if assignee.role != Role.FIELD_STAFF:
            print("Assignee must have field staff role")
            return jsonify({"msg": "Assignee must have field staff role"}), 400
        grievance.assigned_to = assignee_id
        db.session.commit()
        log_audit(f"Grievance {id} reassigned to user {assignee_id}", user.id, id)
        return jsonify({"msg": "Grievance reassigned successfully"}), 200
    except Exception as e:
        current_app.logger.error(f"Error reassigning grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/escalate', methods=['POST'])
@admin_required
def escalate_grievance(user, id):
    try:
        result = escalate_grievance(id, user.id)
        log_audit(f"Grievance {id} escalated by user {user.id}", user.id, id)
        return jsonify(result), 200 if result['success'] else 404
    except Exception as e:
        current_app.logger.error(f"Error escalating grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/search/<string:complaint_id>', methods=['GET'])
@jwt_required_with_role([Role.CITIZEN, Role.MEMBER_HEAD, Role.FIELD_STAFF, Role.ADMIN])
def search_grievance_by_complaint_id(user, complaint_id):
    try:
        grievance = Grievance.query.filter_by(complaint_id=complaint_id).first()
        if not grievance:
            current_app.logger.error(f"Grievance with complaint ID {complaint_id} not found")
            return jsonify({"msg": "Grievance not found"}), 404
        schema = GrievanceSchema()
        return jsonify(schema.dump(grievance)), 200
    except Exception as e:
        current_app.logger.error(f"Error searching grievance by complaint ID {complaint_id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400
    

@grievance_bp.route('/track', methods=['GET'])
@jwt_required_with_role([Role.CITIZEN])
def track_grievances(user):
    try:
        current_app.logger.info(f"Track grievances called for user ID {user.id}")
        grievances = Grievance.query.filter_by(citizen_id=user.id).order_by(Grievance.created_at.desc()).all()

        schema = GrievanceSchema(many=True)
        
        grievances_data = schema.dump(grievances)
        for grievance in grievances_data:
            # Ensure no null values in critical fields
            grievance['id'] = grievance.get('id') or 0
            grievance['citizen_id'] = grievance.get('citizen_id') or user.id
            grievance['subject_id'] = grievance.get('subject_id') or 0
            grievance['area_id'] = grievance.get('area_id') or 0
            grievance['title'] = grievance.get('title') or 'Untitled Grievance'
            grievance['description'] = grievance.get('description') or 'No description provided'
            grievance['complaint_id'] = grievance.get('complaint_id') or str(uuid.uuid4())[:8]
            grievance['citizen'] = grievance.get('citizen') or {'id': 0, 'name': 'Unknown User'}
            grievance['assignee'] = grievance.get('assignee') or {'id': 0, 'name': 'Unassigned'}
            if grievance.get('assigned_to') is None:
                grievance['assigned_to'] = 0
        
        return jsonify(grievances_data), 200
    except Exception as e:
        current_app.logger.error(f"Error tracking grievances for user {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400
    

@grievance_bp.route("/<int:grievance_id>", methods=["PUT"])
@jwt_required_with_role([Role.CITIZEN])
def update_grievance(user, grievance_id):
    """Update grievance details (title, description, area, subject, etc.)"""
    grievance = Grievance.query.get_or_404(grievance_id)
    data = request.get_json()

    # Verify the user owns this grievance (important security check!)
    if grievance.citizen_id != user.id:
        return jsonify({"error": "Unauthorized to update this grievance"}), 403

    if "title" in data:
        grievance.title = data["title"]
    if "description" in data:
        grievance.description = data["description"]
    if "area_id" in data:
        grievance.area_id = data["area_id"]
    if "subject_id" in data:
        grievance.subject_id = data["subject_id"]
    if "address" in data:
        grievance.address = data["address"]

    try:
        db.session.commit()
        return jsonify({
            "message": "✅ Grievance updated successfully",
            "grievance": {
                "id": grievance.id,
                "title": grievance.title,
                "description": grievance.description,
                "address": grievance.address,
                "status": grievance.status.value if grievance.status else None
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500

@grievance_bp.route("/<int:grievance_id>", methods=["DELETE"])
@jwt_required_with_role([Role.CITIZEN, Role.ADMIN])
def delete_grievance(user, grievance_id):
    grievance = Grievance.query.get_or_404(grievance_id)

    # Authorization check: only owner or admin can delete
    if user.role != Role.ADMIN and grievance.citizen_id != user.id:
        return jsonify({"msg": "Permission denied to delete this grievance"}), 403

    db.session.delete(grievance)
    db.session.commit()
    log_audit(f"Grievance {grievance_id} deleted by user {user.id}", user.id, grievance_id)
    return jsonify({"message": "Grievance deleted successfully"})
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\notification_routes.py ---
from flask import Blueprint, request, jsonify
from ..services.notification_service import register_fcm_token
from flask_jwt_extended import jwt_required


notification_bp = Blueprint('notification', __name__)

@notification_bp.route('/register', methods=['POST'])
@jwt_required
def register_notification_token(user):
    data = request.json
    fcm_token = data.get('fcm_token')
    if not fcm_token:
        return jsonify({"msg": "FCM token required"}), 400
    register_fcm_token(user.id, fcm_token)
    return jsonify({"msg": "FCM token registered"}), 200
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\public.py ---
# app/routes/public.py (create if it doesn't exist)
from flask import Blueprint, jsonify
from ..models import MasterSubjects, MasterAreas
from .. import db

public_bp = Blueprint('public', __name__)

@public_bp.route('/subjects', methods=['GET'])
def get_subjects():
    subjects = MasterSubjects.query.all()
    return jsonify([{'id': s.id, 'name': s.name, 'description': s.description} for s in subjects])

@public_bp.route('/areas', methods=['GET'])
def get_areas():
    areas = MasterAreas.query.all()
    return jsonify([{'id': a.id, 'name': a.name, 'description': a.description} for a in areas])
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\settings_routes.py ---
# app/routes.py (or in blueprints)
from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from ..models import User, UserPreference
from .. import db
from ..utils.auth_utils import jwt_required_with_role  # If roles are needed, but since common, no role check

settings_bp = Blueprint('settings', __name__)

@settings_bp.route('/', methods=['GET'])
@jwt_required()
def get_settings():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    if not user:
        return jsonify({"msg": "User not found"}), 404
    
    pref = UserPreference.query.filter_by(user_id=user_id).first()
    return jsonify({
        "name": user.name,
        "email": user.email,
        "notifications_enabled": pref.notifications_enabled if pref else True,
        "language": pref.language if pref else 'en'
    }), 200

@settings_bp.route('/', methods=['POST'])
@jwt_required()
def save_settings():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    if not user:
        return jsonify({"msg": "User not found"}), 404
    
    data = request.json
    if 'name' in data:
        user.name = data['name']
    if 'email' in data:
        user.email = data['email']
    if 'password' in data and data['password']:
        user.set_password(data['password'])

    
    pref = UserPreference.query.filter_by(user_id=user_id).first()
    if not pref:
        pref = UserPreference(user_id=user_id)
        db.session.add(pref)
    
    if 'notifications_enabled' in data:
        pref.notifications_enabled = data['notifications_enabled']
    if 'language' in data:
        pref.language = data['language']
    
    db.session.commit()
    return jsonify({"msg": "Settings saved"}), 200

@settings_bp.route('/user', methods=['GET'])
@jwt_required()
def get_user():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    if not user:
        return jsonify({"msg": "User not found"}), 404
    
    return jsonify({
        "id": user.id,
        "name": user.name,
        "email": user.email,
        "role": user.role.value if user.role else None
    }), 200

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\user_routes.py ---
# app/routes/user_routes.py

from flask import Blueprint, request, jsonify
from ..utils.auth_utils import admin_required, citizen_required, get_jwt_identity
from ..services.user_service import add_update_user
from ..models import User,Role, Grievance, MasterAreas
from ..schemas import GrievanceSchema
from ..schemas import UserSchema
from .. import db

user_bp = Blueprint('user', __name__)

@user_bp.route('/', methods=['GET'] , endpoint='user_list')
@admin_required
def get_users(user):
    """Retrieve all users."""
    try:
        users = User.query.filter(User.role != Role.ADMIN).all()
        schema = UserSchema(many=True)
        return jsonify(schema.dump(users)), 200
    except Exception as e:
        return jsonify({"msg": "Failed to retrieve users", "error": str(e)}), 500

@user_bp.route('/<int:id>', methods=['GET'])
@admin_required
def get_user2(user, id):
    """Retrieve a specific user by ID."""
    try:
        user = User.query.get(id)
        if not user:
            return jsonify({"msg": "User not found"}), 404
        schema = UserSchema()
        return jsonify(schema.dump(user)), 200
    except Exception as e:
        return jsonify({"msg": "Failed to retrieve user", "error": str(e)}), 500



@user_bp.route('/admin/users', methods=['GET'])
@admin_required
def get_users(user):
    """Retrieve all users."""
    try:
        users = User.query.all()
        schema = UserSchema(many=True, exclude=['password'])
        return jsonify(schema.dump(users)), 200
    except Exception as e:
        return jsonify({"msg": "Failed to retrieve users", "error": str(e)}), 500



# Keep your other routes but update the URLs to match
@user_bp.route('/admin/users', methods=['POST'])
@admin_required
def manage_user(user):
    """Add a new user."""
    data = request.json
    
    # Convert role string to Role enum
    if 'role' in data:
        try:
            role_mapping = {
                'citizen': Role.CITIZEN,
                'member_head': Role.MEMBER_HEAD,
                'field_staff': Role.FIELD_STAFF,
                'admin': Role.ADMIN
            }
            if data['role'] in role_mapping:
                data['role'] = role_mapping[data['role']]
            else:
                return jsonify({"msg": f"Invalid role: {data['role']}"}), 400
        except Exception as e:
            return jsonify({"msg": f"Error processing role: {str(e)}"}), 400
    
    try:
        result = add_update_user(data)
        return jsonify(result), 201
    except ValueError as e:
        return jsonify({"msg": str(e)}), 400
    except Exception as e:
        return jsonify({"msg": "An error occurred", "error": str(e)}), 500


    

from flask import Blueprint, request, jsonify
from ..services.user_service import add_update_user, delete_user
from ..utils.file_utils import upload_files
from .. import db
from ..models import User
from flask_jwt_extended import jwt_required, get_jwt_identity

user_routes = Blueprint('users', __name__)

@user_routes.route('/users', methods=['POST'])
@jwt_required()
def update_user():
    try:
        data = request.get_json()
        user = add_update_user(data)
        return jsonify(user), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_routes.route('/users/<int:user_id>', methods=['DELETE'])
@jwt_required()
def delete_user_route(user_id):
    try:
        current_user_id = get_jwt_identity()
        user = User.query.get(current_user_id)
        if user.role != 'admin':
            return jsonify({'error': 'Admin access required'}), 403
        delete_user(user_id)
        return jsonify({'message': 'User deleted successfully'}), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_routes.route('/users/profile-picture', methods=['POST'])
@jwt_required()
def upload_profile_picture():
    try:
        current_user_id = get_jwt_identity()
        if 'file' not in request.files:
            return jsonify({'error': 'No file provided'}), 400
        file = request.files['file']
        uploaded_paths = upload_files([file], current_user_id)
        if not uploaded_paths:
            return jsonify({'error': 'No valid files uploaded'}), 400
        file_path, _, _ = uploaded_paths[0]
        user = User.query.get(current_user_id)
        user.profile_picture = file_path
        db.session.commit()
        return jsonify({'file_path': file_path}), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_routes.route('/areas/<int:area_id>', methods=['GET'])
@jwt_required()
def get_area(area_id):
    try:
        area = db.session.query(MasterAreas).get(area_id)
        if not area:
            return jsonify({'error': 'Area not found'}), 404
        return jsonify({'id': area.id, 'name': area.name, 'description': area.description}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    


=== Folder: app\routes\__pycache__ ===


=== Folder: app\services ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\grievance_service.py ---
from datetime import datetime, timedelta, timezone
from flask import current_app
from marshmallow import ValidationError
from ..models import Grievance, GrievanceAttachment, GrievanceComment, Workproof, GrievanceStatus, Priority, AuditLog, User, NotificationToken, Role, CommentAttachment
from ..schemas import GrievanceSchema, GrievanceAttachmentSchema, GrievanceCommentSchema, WorkproofSchema
from ..utils.file_utils import upload_files, upload_workproof
from .. import db
from ..config import Config
from .notification_service import send_notification
from flask_jwt_extended import get_jwt_identity
from werkzeug.utils import secure_filename
import os
def submit_grievance(citizen_id, data, files):
    try:
        schema = GrievanceSchema()
        try:
            validated_data = schema.load(data)
        except ValidationError as err:
            current_app.logger.error(f"Validation error in submit_grievance: {err.messages}")
            raise ValueError(f"Invalid grievance data: {err.messages}")

        # Create grievance, letting the model handle default priority if not provided
        grievance = Grievance(
            citizen_id=citizen_id,
            subject_id=validated_data['subject_id'],
            area_id=validated_data['area_id'],
            title=validated_data['title'],
            description=validated_data['description'],
            latitude=validated_data.get('latitude'),
            longitude=validated_data.get('longitude'),
            address=validated_data.get('address'),
            status=GrievanceStatus.NEW,
            priority=validated_data.get('priority', Priority.MEDIUM)  # ← Use validated_data or default
        )
        db.session.add(grievance)
        db.session.flush()  # Get grievance ID before committing

        if files:
            try:
                uploaded = upload_files(files, grievance.id)
                for path, typ, size in uploaded:
                    attachment = GrievanceAttachment(
                        grievance_id=grievance.id,
                        file_path=path,
                        file_type=typ,
                        file_size=size
                    )
                    db.session.add(attachment)
            except ValueError as e:
                db.session.rollback()
                current_app.logger.error(f"File upload failed for grievance {grievance.id}: {str(e)}")
                raise ValueError(f"File upload error: {str(e)}")

        db.session.commit()

        log_audit(f'Grievance created (Complaint ID {grievance.complaint_id})', citizen_id, grievance.id)

        token = NotificationToken.query.filter_by(user_id=citizen_id).first()
        send_notification(
            grievance.citizen.email,
            'Grievance Submitted',
            'Your grievance has been submitted.',
            fcm_token=token.fcm_token if token else None
        )
        return schema.dump(grievance)
    except ValidationError as e:
        current_app.logger.error(f"Validation error in submit_grievance: {str(e.messages)}")
        raise ValueError(f"Invalid grievance data: {str(e.messages)}")
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error submitting grievance for citizen {citizen_id}: {str(e)}")
        raise ValueError(f"File upload error: {str(e)}")

        db.session.commit()

        log_audit(f'Grievance created (Complaint ID {grievance.complaint_id})', citizen_id, grievance.id)

        token = NotificationToken.query.filter_by(user_id=citizen_id).first()
        send_notification(
            grievance.citizen.email,
            'Grievance Submitted',
            'Your grievance has been submitted.',
            fcm_token=token.fcm_token if token else None
        )
        return schema.dump(grievance)
    except ValidationError as e:
        current_app.logger.error(f"Validation error in submit_grievance: {str(e.messages)}")
        raise ValueError(f"Invalid grievance data: {str(e.messages)}")
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error submitting grievance for citizen {citizen_id}: {str(e)}")
        raise

def get_my_grievances(citizen_id):
    try:
        grievances = Grievance.query.filter_by(citizen_id=citizen_id).all()
        schema = GrievanceSchema(many=True)
        return schema.dump(grievances)
    except Exception as e:
        current_app.logger.error(f"Error fetching grievances for citizen {citizen_id}: {str(e)}")
        raise

def get_grievance_details(id, user_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance:
            current_app.logger.error(f"Grievance {id} not found")
            return None

        user = db.session.get(User, user_id)
        if not user:
            current_app.logger.error(f"User {user_id} not found")
            return None

        if user.role != Role.ADMIN and grievance.citizen_id != user_id:
            current_app.logger.error(f"User {user_id} not authorized to view grievance {id}")
            return None

        _check_auto_close(grievance)
        schema = GrievanceSchema()
        return schema.dump(grievance)
    except Exception as e:
        current_app.logger.error(f"Error fetching grievance details for ID {id}: {str(e)}")
        raise

def add_comment(grievance_id, user_id, comment_text, files=None):
    grievance = Grievance.query.get_or_404(grievance_id)
    comment = GrievanceComment(
        grievance_id=grievance_id,
        user_id=user_id,
        comment_text=comment_text,
        is_public=True  # Default, or from data
    )
    db.session.add(comment)
    db.session.flush()  # Get comment.id before commit

    uploaded_paths = []
    if files:
        uploaded_paths = upload_files(files, grievance_id)  # Reuse, or create a new folder like 'comment_{comment.id}'

        for path, file_type, file_size in uploaded_paths:
            attachment = CommentAttachment(
                comment_id=comment.id,
                file_path=path,
                file_type=file_type,
                file_size=file_size
            )
            db.session.add(attachment)

    db.session.commit()
    return GrievanceCommentSchema().dump(comment)

def confirm_closure(id, citizen_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.citizen_id != citizen_id or grievance.status != GrievanceStatus.RESOLVED:
            current_app.logger.error(f"Invalid closure attempt for grievance {id} by citizen {citizen_id}")
            raise ValueError("Invalid operation")
        grievance.status = GrievanceStatus.CLOSED
        grievance.updated_at = datetime.now(timezone.utc)
        db.session.commit()
        log_audit('Grievance closed', citizen_id, id)
        send_notification(grievance.citizen.email, 'Grievance Closed', 'Your grievance has been closed.')
        return {"msg": "Closed"}
    except Exception as e:
        current_app.logger.error(f"Error closing grievance {id}: {str(e)}")
        raise

def get_rejection_reason(id, citizen_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.citizen_id != citizen_id or grievance.status != GrievanceStatus.REJECTED:
            current_app.logger.error(f"Invalid rejection reason request for grievance {id} by citizen {citizen_id}")
            raise ValueError("Invalid operation")
        return grievance.rejection_reason
    except Exception as e:
        current_app.logger.error(f"Error fetching rejection reason for grievance {id}: {str(e)}")
        raise

def get_new_grievances():
    try:
        grievances = Grievance.query.order_by(Grievance.created_at.desc()).all()
        
        schema = GrievanceSchema(many=True)
        return schema.dump(grievances)
    except Exception as e:
        current_app.logger.error(f"Error fetching new grievances for department : {str(e)}")
        raise

def accept_grievance(id, head_id, data):
    try:
        current_user_id = get_jwt_identity()
        head_user = db.session.get(User, current_user_id)
        grievance = db.session.get(Grievance, id)

        if not grievance or grievance.status != GrievanceStatus.NEW or grievance.area_id != head_user.department_id:
            current_app.logger.error(f"Invalid accept attempt for grievance {id} by user {head_id}")
            raise ValueError("Invalid operation")
        grievance.priority = Priority[data['priority']]
        grievance.assigned_to = data['assigned_to']
        grievance.assigned_by = head_id
        grievance.status = GrievanceStatus.IN_PROGRESS
        db.session.commit()
        log_audit('Grievance accepted and assigned', head_id, id)
        send_notification(grievance.citizen.email, 'Grievance Accepted', 'Your grievance has been accepted.')
        return {"msg": "Accepted"}
    except Exception as e:
        current_app.logger.error(f"Error accepting grievance {id}: {str(e)}")
        raise

def reject_grievance(id, head_id, reason):
    try:
        
        grievance = db.session.get(Grievance, id)
        # if not grievance or grievance.status != GrievanceStatus.NEW or grievance.area_id != db.session.get(User, head_id).department_id:
        #     current_app.logger.error(f"Invalid reject attempt for grievance {id} by user {head_id}")
        #     raise ValueError("Invalid operation")
        grievance.status = GrievanceStatus.REJECTED
        grievance.rejection_reason = reason
        db.session.commit()
        log_audit('Grievance rejected', head_id, id)
        send_notification(grievance.citizen.email, 'Grievance Rejected', f'Your grievance has been rejected: {reason}')
        return {"msg": "Rejected"}
    except Exception as e:
        current_app.logger.error(f"Error rejecting grievance {id}: {str(e)}")
        raise

def get_assigned_grievances(employer_id):
    try:
        grievances = Grievance.query.filter_by(assigned_to=employer_id).all()
        schema = GrievanceSchema(many=True)
        return schema.dump(grievances)
    except Exception as e:
        current_app.logger.error(f"Error fetching assigned grievances for user {employer_id}: {str(e)}")
        raise

def update_status(id, employer_id, new_status):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.assigned_to != employer_id:
            current_app.logger.error(f"Invalid status update attempt for grievance {id} by user {employer_id}")
            raise ValueError("Invalid operation")
        old_status = grievance.status
        grievance.status = GrievanceStatus[new_status.upper()]
        if grievance.status == GrievanceStatus.RESOLVED:
            grievance.resolved_at = datetime.now(timezone.utc)
        db.session.commit()
        log_audit(f'Status updated from {old_status} to {grievance.status}', employer_id, id)
        send_notification(grievance.citizen.email, 'Status Updated', f'Your grievance status is now {new_status}.')
        return {"msg": "Status updated"}
    except Exception as e:
        current_app.logger.error(f"Error updating status for grievance {id}: {str(e)}")
        raise

def save_file(file, grievance_id):
    """
    Save uploaded file to the UPLOAD_FOLDER, grouped by grievance_id.
    Returns the relative path of the saved file.
    """
    upload_folder = current_app.config.get("UPLOAD_FOLDER", "uploads")
    grievance_folder = os.path.join(upload_folder, str(grievance_id))
    os.makedirs(grievance_folder, exist_ok=True)

    filename = secure_filename(file.filename)
    filepath = os.path.join(grievance_folder, filename)
    file.save(filepath)

    # Return relative path for DB storage (you can also return absolute if you prefer)
    return filepath

def save_workproof_record(grievance_id, employer_id, file, notes):
    try:
        grievance = db.session.get(Grievance, grievance_id)
        if not grievance or grievance.assigned_to != employer_id:
            current_app.logger.error(
                f"Invalid workproof upload attempt for grievance {grievance_id} by user {employer_id}"
            )
            raise ValueError("Invalid operation")

        # ✅ Replace this with your actual file saving utility
        path = save_file(file, grievance_id)

        workproof = Workproof(
            grievance_id=grievance_id,
            uploaded_by=employer_id,
            file_path=path,
            notes=notes,
        )
        db.session.add(workproof)
        db.session.commit()

        schema = WorkproofSchema()
        return schema.dump(workproof)
    except Exception as e:
        current_app.logger.error(f"Error saving workproof for grievance {grievance_id}: {str(e)}")
        raise



def upload_workproof(id, employer_id, file, notes):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.assigned_to != employer_id:
            current_app.logger.error(f"Invalid workproof upload attempt for grievance {id} by user {employer_id}")
            raise ValueError("Invalid operation")

        path = upload_workproof(file, id)   # ❌ Recursive call to itself!

        workproof = Workproof(grievance_id=id, uploaded_by=employer_id, file_path=path, notes=notes)
        db.session.add(workproof)
        db.session.commit()
        schema = WorkproofSchema()
        return schema.dump(workproof)
    except Exception as e:
        current_app.logger.error(f"Error uploading workproof for grievance {id}: {str(e)}")
        raise


def reassign_grievance(id, new_assigned_to, admin_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance:
            current_app.logger.error(f"Grievance {id} not found for reassignment")
            raise ValueError("Grievance not found")
        grievance.assigned_to = new_assigned_to
        db.session.commit()
        log_audit('Grievance reassigned', admin_id, id)
        return {"msg": "Reassigned"}
    except Exception as e:
        current_app.logger.error(f"Error reassigning grievance {id}: {str(e)}")
        raise

def log_audit(action, user_id, grievance_id=None):
    try:
        log = AuditLog(action=action, performed_by=user_id, grievance_id=grievance_id)
        db.session.add(log)
        db.session.commit()
    except Exception as e:
        current_app.logger.error(f"Error logging audit for action {action}: {str(e)}")
        raise

def _check_auto_close(grievance):
    try:
        if grievance.status == GrievanceStatus.RESOLVED and grievance.resolved_at:
            sla_days = int(Config.SLA_CLOSURE_DAYS) if hasattr(Config, 'SLA_CLOSURE_DAYS') else 7
            if datetime.now(timezone.utc) - grievance.resolved_at > timedelta(days=sla_days):
                grievance.status = GrievanceStatus.CLOSED
                db.session.commit()
                log_audit('Auto-closed due to SLA', grievance.assigned_to, grievance.id)
                send_notification(grievance.citizen.email, 'Grievance Auto-Closed', 'Your grievance has been auto-closed.')
    except Exception as e:
        current_app.logger.error(f"Error checking auto-close for grievance {grievance.id}: {str(e)}")
        raise

def escalate_grievance(grievance_id, escalated_by, new_assignee_id=None):
    MAX_ESCALATION_LEVEL = 3
    ESCALATION_FLOW = {
        0: "Assigned Staff",
        1: "Member Head",
        2: "Admin",
        3: "Super Admin"
    }
    try:
        grievance = db.session.get(Grievance, grievance_id)
        if not grievance:
            current_app.logger.error(f"Grievance {grievance_id} not found for escalation")
            raise ValueError("Grievance not found")

        if grievance.escalation_level >= MAX_ESCALATION_LEVEL:
            current_app.logger.error(f"Grievance {grievance_id} already at maximum escalation level")
            return {"success": False, "msg": "Already at maximum escalation level"}

        grievance.escalation_level += 1

        if new_assignee_id:
            new_assignee = db.session.get(User, new_assignee_id)
            if not new_assignee:
                current_app.logger.error(f"New assignee {new_assignee_id} not found")
                raise ValueError("New assignee not found")
            grievance.assigned_to = new_assignee_id
            grievance.assigned_by = escalated_by

        grievance.updated_at = datetime.now(timezone.utc)
        db.session.commit()

        log_audit(
            f"Grievance {grievance_id} escalated to level {grievance.escalation_level}",
            escalated_by,
            grievance_id
        )

        send_notification(
            grievance.citizen.email,
            "Grievance Escalated",
            f"Your grievance #{grievance.id} has been escalated to {ESCALATION_FLOW.get(grievance.escalation_level, 'higher authority')}."
        )
        if grievance.assigned_to:
            assignee = db.session.get(User, grievance.assigned_to)
            if assignee:
                send_notification(
                    assignee.email,
                    "New Escalated Grievance Assigned",
                    f"You have been assigned an escalated grievance #{grievance.id}."
                )

        return {"success": True, "msg": f" Escalated to level {grievance.escalation_level}"}
    except Exception as e:
        current_app.logger.error(f"Error escalating grievance {grievance_id}: {str(e)}")
        raise
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\notification_service.py ---
from flask_mail import Message
from .. import mail
import firebase_admin
from firebase_admin import messaging
from ..models import NotificationToken
from .. import db

def initialize_fcm():
    if not firebase_admin._apps:
        cred = firebase_admin.credentials.Certificate(os.environ.get('FIREBASE_CREDENTIALS'))
        firebase_admin.initialize_app(cred)

def send_notification(to, subject, body, fcm_token=None):
    msg = Message(subject, recipients=[to])
    msg.body = body
    mail.send(msg)

    if fcm_token:
        initialize_fcm()
        message = messaging.Message(
            notification=messaging.Notification(title=subject, body=body),
            token=fcm_token
        )
        messaging.send(message)

def register_fcm_token(user_id, fcm_token):
    token = NotificationToken(user_id=user_id, fcm_token=fcm_token)
    db.session.add(token)
    db.session.commit()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\otp_service.py ---
from twilio.rest import Client
import random
from .. import db
from ..models import OtpToken
from datetime import datetime, timedelta, timezone
import os

def send_otp(phone_number):
    client = Client(os.environ.get('TWILIO_SID'), os.environ.get('TWILIO_AUTH_TOKEN'))
    otp = str(random.randint(100000, 999999))
    message = client.messages.create(
        body=f"Your OTP for Nivaran is {otp}. Valid for 5 minutes.",
        from_=os.environ.get('TWILIO_PHONE_NUMBER'),
        to=phone_number
    )
    otp_token = OtpToken(phone_number=phone_number, otp=otp, expires_at=datetime.now(timezone.utc) + timedelta(minutes=5))
    db.session.add(otp_token)
    db.session.commit()
    return {"msg": "OTP sent"}

def verify_otp(phone_number, otp):
    token = OtpToken.query.filter_by(phone_number=phone_number, otp=otp).first()
    if token and token.expires_at > datetime.now(timezone.utc):
        db.session.delete(token)
        db.session.commit()
        return True
    return False
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\report_service.py ---

# app/services/report_service.py
import pandas as pd
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from io import BytesIO
from sqlalchemy import func, and_
from datetime import datetime, timedelta, timezone
from flask import current_app
from sqlalchemy import func, case
from ..models import Grievance, GrievanceStatus, User, MasterAreas, AuditLog, Role
from .. import db
from .notification_service import send_notification

def generate_report(filter_type='all', format='pdf', user_id=None, area_id=None):
    """
    Generate reports in various formats with filtering options.

    Args:
        filter_type (str): Time period filter ('all', 'day', 'week', 'month', 'year').
        format (str): Output format ('csv', 'excel', 'pdf').
        user_id (int, optional): Filter by specific user ID.
        area_id (int, optional): Filter by specific area ID.

    Returns:
        bytes: Report content in the requested format.

    Raises:
        ValueError: If filter_type or format is invalid.
    """
    valid_filters = ['all', 'day', 'week', 'month', 'year']
    valid_formats = ['csv', 'excel', 'pdf']
    if filter_type not in valid_filters:
        raise ValueError(f"Invalid filter_type. Must be one of {valid_filters}")
    if format not in valid_formats:
        raise ValueError(f"Invalid format. Must be one of {valid_formats}")

    # Build query based on filters
    query = Grievance.query
    
    # Apply time filters
    now = datetime.now(timezone.utc)
    if filter_type == 'day':
        query = query.filter(Grievance.created_at >= now - timedelta(days=1))
    elif filter_type == 'week':
        query = query.filter(Grievance.created_at >= now - timedelta(weeks=1))
    elif filter_type == 'month':
        query = query.filter(Grievance.created_at >= now - timedelta(days=30))
    elif filter_type == 'year':
        query = query.filter(Grievance.created_at >= now - timedelta(days=365))
    
    # Apply user filter
    if user_id:
        query = query.filter(Grievance.citizen_id == user_id)
    
    # Apply area filter
    if area_id:
        query = query.filter(Grievance.area_id == area_id)
    
    # Execute query and convert to DataFrame
    try:
        data = pd.read_sql(query.statement, db.engine)
    except Exception as e:
        raise Exception(f"Failed to fetch grievance data: {str(e)}")
    
    # Generate report in requested format
    if format == 'csv':
        return data.to_csv(index=False).encode('utf-8')
    
    elif format == 'excel':
        output = BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            data.to_excel(writer, index=False, sheet_name='Grievance Report')
            # Add summary statistics
            summary_data = get_summary_statistics(query)
            summary_df = pd.DataFrame(list(summary_data.items()), columns=['Metric', 'Value'])
            summary_df.to_excel(writer, index=False, sheet_name='Summary')
        return output.getvalue()
    
    elif format == 'pdf':
        return generate_pdf_report(data, filter_type, user_id, area_id)
    
    return None

def generate_pdf_report(data, filter_type, user_id, area_id):
    """
    Generate a detailed PDF report.

    Args:
        data (pd.DataFrame): Grievance data.
        filter_type (str): Time period filter.
        user_id (int, optional): User ID filter.
        area_id (int, optional): Area ID filter.

    Returns:
        bytes: PDF content.
    """
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    styles = getSampleStyleSheet()
    
    # Add title
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1  # Center
    )
    
    title_text = f"Grievance Report - {filter_type.capitalize()}"
    if user_id:
        user = User.query.get(user_id)
        title_text += f" - User: {user.name if user else 'Unknown'}"
    if area_id:
        area = MasterAreas.query.get(area_id)
        title_text += f" - Area: {area.name if area else 'Unknown'}"
    
    elements.append(Paragraph(title_text, title_style))
    
    # Add summary statistics
    summary_style = ParagraphStyle(
        'Summary',
        parent=styles['Normal'],
        fontSize=12,
        spaceAfter=12
    )
    
    query = Grievance.query
    if filter_type != 'all':
        now = datetime.now(timezone.utc)
        if filter_type == 'day':
            query = query.filter(Grievance.created_at >= now - timedelta(days=1))
        elif filter_type == 'week':
            query = query.filter(Grievance.created_at >= now - timedelta(weeks=1))
        elif filter_type == 'month':
            query = query.filter(Grievance.created_at >= now - timedelta(days=30))
        elif filter_type == 'year':
            query = query.filter(Grievance.created_at >= now - timedelta(days=365))
    
    if user_id:
        query = query.filter(Grievance.citizen_id == user_id)
    if area_id:
        query = query.filter(Grievance.area_id == area_id)
    
    try:
        summary_data = get_summary_statistics(query)
        summary_text = (
            f"Total Grievances: {summary_data.get('total_grievances', 0)} | "
            f"Resolved: {summary_data.get('resolved_count', 0)} | "
            f"Pending: {summary_data.get('pending_count', 0)}"
        )
        elements.append(Paragraph(summary_text, summary_style))
        elements.append(Spacer(1, 12))
    except Exception as e:
        elements.append(Paragraph(f"Error fetching summary: {str(e)}", summary_style))
        elements.append(Spacer(1, 12))
    
    # Add data table if there's data
    if not data.empty:
        # Prepare table data
        table_data = [list(data.columns)]
        for _, row in data.iterrows():
            table_data.append([str(val) for val in row])  # Convert all values to strings
        
        # Create table
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(table)
    
    # Build PDF
    try:
        doc.build(elements)
        pdf_content = buffer.getvalue()
    except Exception as e:
        buffer.close()
        raise Exception(f"Failed to generate PDF: {str(e)}")
    
    buffer.close()
    return pdf_content

def get_summary_statistics(query):
    """
    Get summary statistics for a query.

    Args:
        query: SQLAlchemy query object for grievances.

    Returns:
        dict: Summary statistics (total_grievances, resolved_count, pending_count).

    Raises:
        Exception: If query execution fails.
    """
    try:
        total_grievances = query.count()
        resolved_count = query.filter(Grievance.status == GrievanceStatus.CLOSED).count()
        pending_count = query.filter(Grievance.status.notin_([
            GrievanceStatus.CLOSED, 
            GrievanceStatus.REJECTED
        ])).count()
        
        return {
            'total_grievances': total_grievances or 0,
            'resolved_count': resolved_count or 0,
            'pending_count': pending_count or 0
        }
    except Exception as e:
        raise Exception(f"Failed to compute summary statistics: {str(e)}")

def get_advanced_kpis(time_period='all'):
    """
    Get advanced KPIs for the system.

    Args:
        time_period (str): Time period filter ('day', 'week', 'month', 'year', 'all').

    Returns:
        dict: Dictionary containing various KPIs (total_complaints, status_overview,
              dept_wise, sla_metrics, staff_performance).

    Raises:
        ValueError: If time_period is invalid.
        Exception: If database queries fail.
    """
    valid_periods = ['day', 'week', 'month', 'year', 'all']
    if time_period not in valid_periods:
        raise ValueError(f"Invalid time_period. Must be one of {valid_periods}")

    try:
        # Calculate time filter
        now = datetime.now(timezone.utc)
        if time_period == 'day':
            time_filter = Grievance.created_at >= now - timedelta(days=1)
        elif time_period == 'week':
            time_filter = Grievance.created_at >= now - timedelta(weeks=1)
        elif time_period == 'month':
            time_filter = Grievance.created_at >= now - timedelta(days=30)
        elif time_period == 'year':
            time_filter = Grievance.created_at >= now - timedelta(days=365)
        else:
            time_filter = True  # No filter for 'all'
        
        # Total complaints by time period
        total_complaints = {
            'day': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(days=1))
                    .scalar() or 0,
            'week': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(weeks=1))
                    .scalar() or 0,
            'month': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(days=30))
                    .scalar() or 0,
            'year': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(days=365))
                    .scalar() or 0,
            'all': db.session.query(func.count(Grievance.id))
                    .scalar() or 0
        }
        
        # Status overview
        status_counts = db.session.query(
            Grievance.status, 
            func.count(Grievance.id)
        ).filter(time_filter).group_by(Grievance.status).all()
        status_overview = {status.value: count for status, count in status_counts}
        
        # Ensure all possible statuses are included
        for status in GrievanceStatus:
            if status.value not in status_overview:
                status_overview[status.value] = 0
        
        # Department-wise distribution
        dept_wise = dict(db.session.query(
            MasterAreas.name, 
            func.count(Grievance.id)
        ).join(Grievance, MasterAreas.id == Grievance.area_id)
        .filter(time_filter)
        .group_by(MasterAreas.id, MasterAreas.name).all())
        
        # SLA compliance metrics
        resolved_grievances = Grievance.query.filter(
            and_(Grievance.status == GrievanceStatus.CLOSED, time_filter)
        )
        
        sla_days = current_app.config.get('SLA_CLOSURE_DAYS', 7)
        sla_compliant = resolved_grievances.filter(
            Grievance.updated_at - Grievance.created_at <= timedelta(days=sla_days)
        ).count()
        
        total_resolved = resolved_grievances.count()
        sla_compliance_rate = (sla_compliant / total_resolved * 100) if total_resolved > 0 else 0
        
        # Staff performance
        staff_performance = dict(db.session.query(
            User.name, 
            func.count(Grievance.id)
        ).join(Grievance, User.id == Grievance.assigned_to)
        .filter(and_(Grievance.status == GrievanceStatus.CLOSED, time_filter))
        .group_by(User.id, User.name).all())
        
        # Average resolution time
        avg_resolution_time = db.session.query(
            func.avg(func.julianday(Grievance.updated_at) - func.julianday(Grievance.created_at))
        ).filter(and_(Grievance.status == GrievanceStatus.CLOSED, time_filter)).scalar() or 0
        
        return {
            'total_complaints': total_complaints,
            'status_overview': status_overview,
            'dept_wise': dept_wise or {},
            'sla_metrics': {
                'sla_days': sla_days,
                'sla_compliant': sla_compliant or 0,
                'total_resolved': total_resolved or 0,
                'sla_compliance_rate': round(sla_compliance_rate, 2),
                'avg_resolution_time_days': round(avg_resolution_time, 2)
            },
            'staff_performance': staff_performance or {}
        }
    except Exception as e:
        raise Exception(f"Failed to compute KPIs: {str(e)}")

def get_citizen_history(user_id):
    """
    Get grievance history for a specific citizen.

    Args:
        user_id (int): ID of the citizen.

    Returns:
        list: List of grievance records.

    Raises:
        Exception: If query execution fails.
    """
    try:
        return Grievance.query.filter_by(citizen_id=user_id).all()
    except Exception as e:
        raise Exception(f"Failed to fetch citizen history: {str(e)}")

def escalate_grievance(grievance_id, escalated_by, new_assignee_id=None):
    """
    Escalate a grievance to a higher level.

    Args:
        grievance_id (int): ID of the grievance to escalate.
        escalated_by (int): ID of the user performing the escalation.
        new_assignee_id (int, optional): ID of the new assignee.

    Returns:
        dict: Result of the escalation operation.

    Raises:
        Exception: If the grievance is not found or escalation fails.
    """
    try:
        grievance = Grievance.query.get(grievance_id)
        if not grievance:
            return {"success": False, "message": "Grievance not found"}
        
        max_escalation_level = int(current_app.config.get('MAX_ESCALATION_LEVEL', 3))
        if grievance.escalation_level >= max_escalation_level:
            return {"success": False, "message": f"Cannot escalate beyond level {max_escalation_level}"}
        
        # Increment escalation level
        grievance.escalation_level = (grievance.escalation_level or 0) + 1
        
        # Update status
        grievance.status = GrievanceStatus.ON_HOLD
        
        # Optionally reassign to a new user
        if new_assignee_id:
            assignee = User.query.get(new_assignee_id)
            if not assignee:
                return {"success": False, "message": "Assignee not found"}
            grievance.assigned_to = new_assignee_id
            grievance.assigned_by = escalated_by
        
        # Update timestamps
        grievance.updated_at = datetime.now(timezone.utc)
        
        # Log the escalation
        log_audit(f'Grievance escalated to level {grievance.escalation_level}', escalated_by, grievance_id)
        
        db.session.commit()
        
        # Notify administrators and new assignee (if applicable)
        admins = User.query.filter_by(role=Role.ADMIN).all()
        for admin in admins:
            send_notification(
                admin.email,
                'Grievance Escalated',
                f'Grievance #{grievance_id} has been escalated to level {grievance.escalation_level}'
            )
        if new_assignee_id:
            assignee = User.query.get(new_assignee_id)
            if assignee:
                send_notification(
                    assignee.email,
                    'Grievance Assigned',
                    f'You have been assigned escalated grievance #{grievance_id} (Level {grievance.escalation_level})'
                )
        
        return {"success": True, "message": f"Grievance escalated to level {grievance.escalation_level}"}
    except Exception as e:
        db.session.rollback()
        raise Exception(f"Failed to escalate grievance: {str(e)}")

def log_audit(action, user_id, grievance_id=None):
    """
    Log an audit action.

    Args:
        action (str): Description of the action.
        user_id (int): ID of the user performing the action.
        grievance_id (int, optional): ID of the related grievance.

    Raises:
        Exception: If audit logging fails.
    """
    try:
        log = AuditLog(action=action, performed_by=user_id, grievance_id=grievance_id)
        db.session.add(log)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        raise Exception(f"Failed to log audit: {str(e)}")

def get_staff_performance():
    """
    Generate staff performance metrics:
    - Total complaints assigned
    - Complaints resolved
    - Avg resolution time (hours)
    - Avg citizen feedback rating
    """

    query = (
        db.session.query(
            User.id.label("staff_id"),
            User.name.label("staff_name"),
            func.count(Grievance.id).label("total_assigned"),
            func.sum(case((Grievance.status == GrievanceStatus.CLOSED, 1), else_=0)).label("resolved_count"),
            func.avg(case((Grievance.status == GrievanceStatus.CLOSED,
                           func.strftime('%s', Grievance.resolved_at) - func.strftime('%s', Grievance.created_at)))).label("avg_resolution_time_seconds"),
            func.avg(Grievance.feedback_rating).label("avg_feedback_rating")
        )
        .join(User, User.id == Grievance.assigned_to)
        .filter(User.role == Role.EMPLOYER)
        .group_by(User.id, User.name)
    ).all()

    results = []
    for row in query:
        results.append({
            "staff_id": row.staff_id,
            "staff_name": row.staff_name,
            "total_assigned": int(row.total_assigned or 0),
            "resolved_count": int(row.resolved_count or 0),
            "avg_resolution_time_hours": round((row.avg_resolution_time_seconds or 0) / 3600, 2),
            "avg_feedback_rating": round(row.avg_feedback_rating or 0, 2)
        })
    return results

def get_location_reports():
    """
    Location-based grievance reports:
    - Complaints per ward
    - Complaints per geo-location cluster
    """
    ward_data = (
        db.session.query(
            Grievance.ward_number,
            func.count(Grievance.id).label("total_complaints"),
            func.sum(case((Grievance.status == GrievanceStatus.CLOSED, 1), else_=0)).label("resolved"),
            func.sum(case((Grievance.status.notin_([GrievanceStatus.CLOSED, GrievanceStatus.REJECTED]), 1), else_=0)).label("pending")
        )
        .group_by(Grievance.ward_number)
        .all()
    )

    return [
        {
            "ward_number": row.ward_number or "Unknown",
            "total_complaints": int(row.total_complaints or 0),
            "resolved": int(row.resolved or 0),
            "pending": int(row.pending or 0)
        }
        for row in ward_data
    ]

def update_grievance_status(grievance_id, new_status, updated_by):
    """
    Update the status of a grievance.

    Args:
        grievance_id (int): ID of the grievance to update.
        new_status (str): New status to set.
        updated_by (int): ID of the user updating the status.

    Returns:
        dict: Result of the status update operation.

    Raises:
        Exception: If the grievance is not found or status update fails.
    """
    try:
        grievance = Grievance.query.get(grievance_id)
        if not grievance:
            return {"success": False, "message": "Grievance not found"}
        
        # Validate new status
        valid_statuses = [e.value for e in GrievanceStatus]
        if new_status not in valid_statuses:
            return {"success": False, "message": f"Invalid status. Must be one of {valid_statuses}"}
        
        # Update status
        grievance.status = GrievanceStatus(new_status)
        grievance.updated_at = datetime.now(timezone.utc)
        
        # If status is resolved or closed, set resolved_at
        if new_status in [GrievanceStatus.RESOLVED.value, GrievanceStatus.CLOSED.value]:
            grievance.resolved_at = datetime.now(timezone.utc)
        
        # Log the status update
        log_audit(f'Grievance status updated to {new_status}', updated_by, grievance_id)
        
        db.session.commit()
        
        # Notify the citizen
        citizen = User.query.get(grievance.citizen_id)
        if citizen and citizen.email:
            send_notification(
                citizen.email,
                'Grievance Status Updated',
                f'Your grievance #{grievance_id} has been updated to status: {new_status}'
            )
        
        return {"success": True, "message": f"Grievance status updated to {new_status}"}
    except Exception as e:
        db.session.rollback()
        raise Exception(f"Failed to update grievance status: {str(e)}")
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\user_service.py ---
# app/services/user_service.py

from ..models import User, Role
from ..schemas import UserSchema
from .. import db

def add_update_user(data, user_id=None): 
    schema = UserSchema()
    data.pop("id", None)

    # Extract password separately before schema load
    raw_password = data.pop("password", None)

    user_data = schema.load(data, partial=True)
    print(f"Received user data: {user_data}")

    if user_id:  
        user = db.session.get(User, user_id)
        if not user:
            raise ValueError("User not found")
        print(f"Updating user {user_id} with data: {user_data}")
        for key, value in user_data.items():
            setattr(user, key, value)
    else:
        if User.query.filter_by(email=user_data.get('email')).first():
            raise ValueError("Email already exists")
        if User.query.filter_by(phone_number=user_data.get('phone_number')).first():
            raise ValueError("Phone number already exists")
        user = User(**user_data)
        db.session.add(user)

    # ✅ Handle password securely
    if raw_password:
        user.set_password(raw_password)

    db.session.commit()
    return schema.dump(user)



def delete_user(user_id):
    user = db.session.get(User, user_id)
    if not user:
        raise ValueError("User not found")
    db.session.delete(user)
    db.session.commit()

def get_users():
    """
    Fetch all users, particularly those suitable for grievance assignment (e.g., FIELD_STAFF).
    """
    try:
        users = User.query.filter_by(role=Role.FIELD_STAFF).all()
        return [UserSchema().dump(user) for user in users]
    except Exception as e:
        raise Exception(f"Failed to fetch users: {str(e)}")

=== Folder: app\services\__pycache__ ===


=== Folder: app\utils ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\utils\auth_utils.py ---
# app/utils/auth_utils.py

from functools import wraps
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity
from flask import jsonify
from ..models import User, Role
from .. import db
def jwt_required_with_role(roles):
    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            verify_jwt_in_request()
            current_user_id = get_jwt_identity()
            print(f"JWT Identity: {current_user_id}")
            user = db.session.get(User, current_user_id)
            if not user:
                print("User not found for ID:", current_user_id)
                return jsonify({"msg": "User not found"}), 404
            if user.role not in roles:
                print(f"Access forbidden: User role {user.role} not in {roles}")
                return jsonify({"msg": "Access forbidden"}), 403
            return fn(user, *args, **kwargs)
        return decorator
    return wrapper

# Role decorators
def citizen_required(fn):
    return jwt_required_with_role([Role.CITIZEN])(fn)

def member_head_required(fn):
    return jwt_required_with_role([Role.MEMBER_HEAD])(fn)

def field_staff_required(fn):
    return jwt_required_with_role([Role.FIELD_STAFF])(fn)

def admin_required(fn):
    return jwt_required_with_role([Role.ADMIN])(fn)

def citizen_or_admin_required(fn):  # New decorator
    return jwt_required_with_role([Role.CITIZEN, Role.ADMIN,Role.MEMBER_HEAD,Role.FIELD_STAFF])(fn)

def field_staff_or_admin_required(fn):  # New decorator
    return jwt_required_with_role([Role.FIELD_STAFF, Role.ADMIN, Role.MEMBER_HEAD])(fn)
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\utils\file_utils.py ---
# app/utils/file_utils.py

import os
from werkzeug.utils import secure_filename
from flask import current_app
from mimetypes import guess_type

def allowed_file(filename):
    # Get MIME type of the file
    mime_type, _ = guess_type(filename)
    
    # Define allowed MIME types
    allowed_mime_types = [
        'image/jpeg',       # jpg/jpeg
        'image/png',        # png
        'application/pdf',  # pdf
        'text/plain',       # txt
        'video/mp4',        # mp4
        'video/quicktime'   # mov
    ]
    
    # Check file extension and MIME type
    return (
        '.' in filename and
        filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS'] and
        mime_type in allowed_mime_types
    )

def upload_files(files, grievance_id):
    uploaded_paths = []
    base_upload_folder = current_app.config['UPLOAD_FOLDER']
    relative_grievance_folder = f'grievance_{grievance_id}'
    absolute_grievance_folder = os.path.join(base_upload_folder, relative_grievance_folder)
    os.makedirs(absolute_grievance_folder, exist_ok=True)
    
    if len(files) > 10:
        raise ValueError("Maximum 10 files allowed")
    
    for file in files:
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            absolute_file_path = os.path.join(absolute_grievance_folder, filename)
            file.save(absolute_file_path)
            
            # Store the relative path for URL generation, replacing backslashes
            relative_file_path = os.path.join(relative_grievance_folder, filename).replace('\\', '/')
            
            file_size = os.path.getsize(absolute_file_path)
            uploaded_paths.append((relative_file_path, filename.rsplit('.', 1)[1].lower(), file_size))
        else:
            raise ValueError("Invalid file type")
    
    return uploaded_paths

def upload_workproof(file, grievance_id):
    if not allowed_file(file.filename):
        raise ValueError("Invalid file type")
    
    base_upload_folder = current_app.config['UPLOAD_FOLDER']
    relative_workproof_folder = f'workproof_{grievance_id}'
    absolute_workproof_folder = os.path.join(base_upload_folder, relative_workproof_folder)
    os.makedirs(absolute_workproof_folder, exist_ok=True)
    
    filename = secure_filename(file.filename)
    absolute_file_path = os.path.join(absolute_workproof_folder, filename)
    file.save(absolute_file_path)
    
    # Return the relative path for URL generation, replacing backslashes
    return os.path.join(relative_workproof_folder, filename).replace('\\', '/')
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\utils\kpi_utils.py ---
# app/utils/kpi_utils.py

from datetime import datetime, timedelta
from ..models import Grievance, GrievanceStatus, MasterAreas
from .. import db
from sqlalchemy import func

def calculate_resolution_rate():
    total_resolved = Grievance.query.filter_by(status=GrievanceStatus.CLOSED).count()
    total_grievances = Grievance.query.count()
    return (total_resolved / total_grievances * 100) if total_grievances > 0 else 0

def calculate_pending_aging():
    pending = Grievance.query.filter(Grievance.status.notin_([GrievanceStatus.CLOSED, GrievanceStatus.REJECTED]))
    aging = db.session.query(func.avg(func.julianday(datetime.utcnow()) - func.julianday(Grievance.created_at))).filter(Grievance.status.notin_([GrievanceStatus.CLOSED, GrievanceStatus.REJECTED])).scalar()
    return {
        'pending_count': pending.count(),
        'average_aging_days': aging or 0
    }

def calculate_sla_compliance():
    # Assuming SLA is resolution within 30 days for example
    resolved = Grievance.query.filter_by(status=GrievanceStatus.CLOSED)
    compliant = resolved.filter(Grievance.updated_at - Grievance.created_at <= timedelta(days=30)).count()
    total_resolved = resolved.count()
    return (compliant / total_resolved * 100) if total_resolved > 0 else 0

def calculate_dept_wise_resolution():
    return db.session.query(MasterAreas.name, func.avg(Grievance.updated_at - Grievance.created_at)).join(MasterAreas).group_by(MasterAreas.id).all()

=== Folder: app\utils\__pycache__ ===


=== Folder: app\__pycache__ ===


=== Folder: uploads ===


=== Folder: uploads\3 ===


=== Folder: uploads\grievance_10 ===


=== Folder: uploads\grievance_11 ===


=== Folder: uploads\user_1 ===


=== Folder: uploads\user_19 ===
