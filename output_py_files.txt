

=== Folder: . ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\addConfig.py ---
# addConfig.py
from app import create_app, db
from app.models import MasterConfig, Priority
from datetime import datetime

def insert_master_configs():
    configs = [
        ("MAX_ESCALATION_LEVEL", "3"),
        ("SLA_CLOSURE_DAYS", "7"),
        ("DEFAULT_PRIORITY", Priority.MEDIUM.value),  # Use enum value
    ]

    inserted, updated = 0, 0
    for key, value in configs:
        config = MasterConfig.query.filter_by(key=key).first()
        if config:
            config.value = value
            config.updated_at = datetime.utcnow()
            updated += 1
        else:
            new_config = MasterConfig(key=key, value=value)
            db.session.add(new_config)
            inserted += 1

    db.session.commit()
    print(f"✅ Inserted {inserted}, Updated {updated} master_configs successfully!")

if __name__ == "__main__":
    app = create_app()
    with app.app_context():
        insert_master_configs()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\addData.py ---
# addData.py

from app import create_app, db   # use your factory or app instance
from app.models import MasterAreas  # adjust import if needed

def insert_master_areas():
    areas = [
        ("Nigdi-Prdhikaran", "निगडी - प्राधिकरण"),
        ("Akurdi", "आकुर्डी"),
        ("Chinchwadgaon", "चिंचवडगांव"),
        ("Thergaon", "थेरगांव"),
        ("Kiwale", "किवळे"),
        ("Ravet", "रावेत"),
        ("Mamurdi", "मामुर्डी"),
        ("Wakad", "वाकड"),
        ("Punawale", "पुनावळे"),
        ("Bopkhel", "बोपखेल"),
        ("Dapodi-Fugewadi", "दापोडी फुगेवाडी"),
        ("Talawade", "तळवडे"),
        ("Morwadi", "मोरवाडी"),
        ("Bhosari", "भोसरी"),
        ("Chikhali", "चिखली"),
        ("Charholi", "च-होली"),
        ("Moshi", "मोशी"),
        ("Pimprigaon", "पिंपरीगांव"),
        ("Kharalwadi", "खराळवाडी"),
        ("Kasarwadi", "कासारवाडी"),
        ("Kalewadi-Rahatani", "काळेवाडी रहाटणी"),
        ("Chinchwad-Station", "चिंचवड स्टेशन"),
        ("Pimple-Nilakh", "पिंपळे निलख"),
        ("Pimple-Saudagar", "पिंपळे सौदागर"),
        ("Pimple-Gurav", "पिंपळे गुरव"),
        ("New-Sangvi", "नवी सांगवी"),
        ("Old-Sangvi", "जुनी सांगवी"),
        ("Sambhaji-Nagar", "संभाजीनगर"),
        ("Sant-Tukaram-Nagar", "संत तुकाराम नगर"),
        ("Nehru-Nagar", "नेहरूनगर"),
        ("Pimpri-Camp", "पिंपरी कॅम्प"),
        ("Yamuna-Nagar", "यमुनानगर"),
        ("Masulkar-Colony", "मासुळकर कॉलनी"),
        ("Dighi", "दिघी"),
        ("Tathawade", "ताथवडे"),
        ("Dudulgaon", "डुडूळगांव"),
        ("Wadmukhwadi", "वडमुखवाडी"),
        ("AII-PCMC", "पिं.चिं. शहर"),
        ("Walhekar Wadi", "वाल्हेकरवाडी"),
        ("Bhatnagar", "भाटनगर"),
        ("Jadhavwadi-KudalWadi", "जाधववाडी-कुदळवाडी"),
        ("Indrayani Nagar", "इंद्रायणी नगर"),
        ("Rupi Nagar", "रुपीनगर"),
        ("Kalbhor Nagar", "काळभोरनगर"),
        ("Chinchwade Nagar", "चिंचवडेनगर"),
        ("Shivtej Nagar Chikhali", "शिवतेज नगर चिखली"),
    ]

    objects = [MasterAreas(name=name, description=desc) for name, desc in areas]
    db.session.bulk_save_objects(objects)
    db.session.commit()
    print(f"✅ Inserted {len(objects)} master_areas successfully!")

if __name__ == "__main__":
    app = create_app()  # if you use app factory pattern
    with app.app_context():
        insert_master_areas()

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\addData_Subject.py ---
# addSubjects.py

from app import create_app, db   # adjust if you import app directly
from app.models import MasterSubjects  # make sure MasterSubject model exists

def insert_master_subjects():
    subjects = [
        ("रस्त्यावरील खड्डयांबाबत", "Pot Holes"),
        ("सार्वजनिक शौचालय साफसफाईबाबत", "Cleaning of Public Toilets"),
        ("अनाधिकृत टपऱ्या / हातगाड्या / फेरीवाल्यांबाबत", "Unauthorised Stalls & Hawkers"),
        ("अनाधिकृत मोबाईल टॉवरबाबत", "Unauthorised Mobile Tower"),
        ("किटकनाशक फवारणी", "Spraying Of Pesticides"),
        ("रस्ते दुरूस्ती", "Road repairing"),
        ("पाणी समस्या", "Water problem"),
        ("ड्रेनेज तुंबलेबाबत", "Drainage blockage"),
        ("रस्त्यावरील विद्युत दिव्यांबाबत", "Street lights"),
        ("परिसर साफसफाई / कचरा उचलणेबाबत", "Area Cleaning / Garbage lifting"),
        ("ध्वनी प्रदुषणाबाबत", "Sound Pollution"),
        ("इतर", "Other"),
        ("मृत जनावर", "Dead animal"),
        ("कचराकुंडी साफ नाहीत", "Dustbins not cleaned"),
        ("कचरा गाडीबाबत", "Garbage vehicle not arrived"),
        ("सार्वजनिक स्वच्छतागृहातील विदयुत दिव्याबाबत", "No electricity in public toilet"),
        ("सार्वजनिक स्वच्छतागृहातील पाणी समस्याबाबत", "No water supply in public toilet"),
        ("सार्वजनिक स्वच्छतागृहातील साफसफाईबाबत", "Public toilet blockage-cleaning"),
        ("गतिरोधक", "Speed Breaker"),
        ("कमी दाबाने पाणी पुरवठा", "Low Water Pressure"),
        ("दुषित पाणी पुरवठा", "Contaminated Water Supply"),
        ("अनियमित पाणी पुरवठा", "Irregular Water Supply"),
        ("पाईपलाईन लीकेज", "Pipeline Leakage"),
        ("पेविंग ब्लॉक", "Paving Block"),
        ("वृक्ष छाटणी", "Tree Cutting"),
        ("फुटपाथ दुरुस्ती बाबत", "Regarding pavement repair"),
        ("फुटपाथ साफसफाई बाबत", "Clean Sidewalk"),
        ("भटक्या कुत्र्यांसाठी जन्म नियंत्रण बाबत", "Birth Control for Stray Dogs"),
        ("आजारी किंवा जखमी भटका कुत्रा बाबत", "Sick or Injured Stray Dog"),
        ("भटक्या कुत्र्याने चावा बाबत", "Bite by Stray Dog"),
        ("मोठे मृत जनावरांची विल्हेवाट लावणे बाबत", "Disposal of large dead animals"),
        ("रेबीज ग्रस्त श्वानांची तक्रार बाबत", "Complaints of rabies dogs"),
    ]

    objects = [MasterSubjects(name=eng, description=mar) for mar, eng in subjects]
    db.session.bulk_save_objects(objects)
    db.session.commit()
    print(f"✅ Inserted {len(objects)} master_subjects successfully!")

if __name__ == "__main__":
    app = create_app()  # if you use factory pattern
    with app.app_context():
        insert_master_subjects()

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\run.py ---
# run.py

from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\testusers.py ---
# create_users.py
from app import create_app, db
from app.models import User, Role
from datetime import datetime, timezone

def create_test_users():
    users = [
        {
            "name": "Test Citizen",
            "email": "citizen@test.com",
            "phone_number": "+1234567890",
            "password": "password123",
            "role": Role.CITIZEN,
            "department_id": None
        },
        {
            "name": "Test Member Head",
            "email": "memberhead@test.com",
            "phone_number": "+1234567891",
            "password": "password123",
            "role": Role.MEMBER_HEAD,
            "department_id": 1  # Assumes area ID 1 exists
        },
        {
            "name": "Test Field Staff",
            "email": "fieldstaff@test.com",
            "phone_number": "+1234567892",
            "password": "password123",
            "role": Role.FIELD_STAFF,
            "department_id": 1
        },
        {
            "name": "Test Admin",
            "email": "admin@test.com",
            "phone_number": "+1234567893",
            "password": "password123",
            "role": Role.ADMIN,
            "department_id": None
        }
    ]

    for user_data in users:
        # Check if user already exists
        if User.query.filter_by(email=user_data["email"]).first():
            print(f"User {user_data['email']} already exists, skipping.")
            continue
        
        user = User(
            name=user_data["name"],
            email=user_data["email"],
            phone_number=user_data["phone_number"],
            role=user_data["role"],
            department_id=user_data["department_id"],
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )
        user.set_password(user_data["password"])
        db.session.add(user)
        print(f"Created user: {user_data['name']} ({user_data['role'].value})")
    
    db.session.commit()
    print("✅ All users created successfully!")

if __name__ == "__main__":
    app = create_app()
    with app.app_context():
        create_test_users()

=== Folder: .pytest_cache ===


=== Folder: .pytest_cache\v ===


=== Folder: .pytest_cache\v\cache ===


=== Folder: app ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\config.py ---
# app/config.py

import os
from datetime import timedelta
from dotenv import load_dotenv

# The base directory of the application
basedir = os.path.abspath(os.path.dirname(__file__))

# Load environment variables from a .env file at the project root
# This is useful for development.
# Create a .env file in the root directory and add your environment-specific variables there.
# See .env.example for a template.
load_dotenv(os.path.join(basedir, '..', '.env'))

class Config:
    """
    Base configuration class.
    Contains default configuration settings and settings loaded from environment variables.
    """
    # --- General Flask Settings ---
    # A secret key is required for session management, flash messages, and other security features.
    # In production, this MUST be a long, random, and secret string.
    # You can generate one using: python -c 'import secrets; print(secrets.token_hex(16))'
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'a-hard-to-guess-string-for-dev'

    # --- Database Settings ---
    # Defines the database connection URI.
    # The default is an SQLite database named 'app.db' in the project root, which is good for development.
    # For production, you should use a more robust database like PostgreSQL or MySQL.
    # Example for PostgreSQL: DATABASE_URL="postgresql://user:password@host:port/dbname"
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or f'sqlite:///{os.path.join(basedir, "..", "app.db")}'
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    # --- JWT (JSON Web Token) Settings ---
    # Secret key for signing JWTs. This should also be a strong, secret value in production.
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'another-super-secret-jwt-key-for-dev'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=60)

    # --- File Upload Settings ---
    UPLOAD_FOLDER = os.path.join(basedir, '..', 'uploads')
    ALLOWED_EXTENSIONS = {'pdf', 'txt', 'jpg', 'jpeg', 'png', 'mp4', 'mov'}
    MAX_CONTENT_LENGTH = 50 * 1024 * 1024  # 16MB max file size

    # --- Email Settings ---
    # To send emails, you need to configure an SMTP server.
    # For development, you can use a service like Mailtrap.io or a local debugging server.
    # The settings below are configured to use environment variables, with Google's SMTP as the default.
    # For this to work, you must enable 2-Step Verification on your Google account and generate an "App Password".
    # If you don't set these in your .env, email sending will likely fail.
    MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'smtp.gmail.com'
    MAIL_PORT = int(os.environ.get('MAIL_PORT') or 587)
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'True').lower() in ('true', '1', 't')
    MAIL_USE_SSL = os.environ.get('MAIL_USE_SSL', 'False').lower() in ('true', '1', 't')
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER') or ('Grievance System', os.environ.get('MAIL_USERNAME'))

    # --- Google OAuth Settings ---
    # These are required for Google Sign-In to work.
    # You must create a project in the Google Cloud Console (https://console.cloud.google.com/)
    # and get "OAuth 2.0 Client ID" credentials.
    # If these are not set, the Google login feature should be disabled or handled gracefully in the code.
    GOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID')
    GOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET')
    GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"


--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\extensions.py ---
from authlib.integrations.flask_client import OAuth

oauth = OAuth()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\models.py ---
# app/models.py

from datetime import datetime,timezone  
from werkzeug.security import generate_password_hash, check_password_hash
from . import db
from enum import Enum
import uuid



class Role(Enum):
    CITIZEN = 'citizen'
    MEMBER_HEAD = 'member_head'
    FIELD_STAFF  = 'field_staff'
    ADMIN = 'admin'

class GrievanceStatus(Enum):
    NEW = 'new'
    IN_PROGRESS = 'in_progress'
    ON_HOLD = 'on_hold'
    RESOLVED = 'resolved'
    CLOSED = 'closed'
    REJECTED = 'rejected'

class Priority(Enum):
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    URGENT = 'urgent'

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(128), unique=True, nullable=True)
    phone_number = db.Column(db.String(15), unique=True, nullable=True) 
    password_hash = db.Column(db.String(256), nullable=True)
    role = db.Column(db.Enum(Role), nullable=False)
    department_id = db.Column(db.Integer, db.ForeignKey('master_areas.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Grievance(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    complaint_id = db.Column(db.String(50), unique=True, nullable=False, default=lambda: str(uuid.uuid4())[:8]) 
    citizen_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    subject_id = db.Column(db.Integer, db.ForeignKey('master_subjects.id'), nullable=False)
    area_id = db.Column(db.Integer, db.ForeignKey('master_areas.id'), nullable=False)
    title = db.Column(db.String(256), nullable=False)
    description = db.Column(db.Text, nullable=False)
    ward_number = db.Column(db.String(50), nullable=True)


    status = db.Column(db.Enum(GrievanceStatus), default=GrievanceStatus.NEW, nullable=False)
    priority = db.Column(db.Enum(Priority), default=Priority.MEDIUM, nullable=True)
    assigned_to = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    assigned_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    rejection_reason = db.Column(db.Text, nullable=True)
    resolved_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    latitude = db.Column(db.Float, nullable=True)
    longitude = db.Column(db.Float, nullable=True)
    address = db.Column(db.String(256), nullable=True)

    escalation_level = db.Column(db.Integer, default=0)  # For escalation tracking
    feedback_rating = db.Column(db.Integer, nullable=True)  # 1-5 star rating
    feedback_text = db.Column(db.Text, nullable=True)

    # Relationships
    citizen = db.relationship('User', backref=db.backref('submitted_grievances', lazy=True), foreign_keys=[citizen_id])
    assignee = db.relationship('User', backref=db.backref('assigned_grievances', lazy=True), foreign_keys=[assigned_to])
    subject = db.relationship('MasterSubjects')
    area = db.relationship('MasterAreas')
    attachments = db.relationship('GrievanceAttachment', backref='grievance', lazy='dynamic', cascade="all, delete-orphan")
    comments = db.relationship('GrievanceComment', backref='grievance', lazy='dynamic', cascade="all, delete-orphan")

class GrievanceAttachment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=False)
    file_path = db.Column(db.String(256), nullable=False)
    file_type = db.Column(db.String(10), nullable=False)  # e.g., 'pdf', 'jpeg'
    
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

class GrievanceComment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    comment_text = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    # Relationship to User
    user = db.relationship('User', backref='comments')

class Workproof(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=False)
    uploaded_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    file_path = db.Column(db.String(256), nullable=False)
    notes = db.Column(db.Text, nullable=True)
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

class MasterSubjects(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    description = db.Column(db.Text, nullable=True)

class MasterAreas(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    description = db.Column(db.Text, nullable=True)

class AuditLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    action = db.Column(db.Text, nullable=False)
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    grievance_id = db.Column(db.Integer, db.ForeignKey('grievance.id'), nullable=True)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

class OtpToken(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    phone_number = db.Column(db.String(15), nullable=False)
    otp = db.Column(db.String(6), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)

class NotificationToken(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    fcm_token = db.Column(db.String(256), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

# Add to your models.py
class MasterConfig(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(128), unique=True, nullable=False)
    value = db.Column(db.String(256), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

# app/models.py
class Announcement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(256), nullable=False)
    message = db.Column(db.Text, nullable=False)
    type = db.Column(db.String(50), default="general")  # general / emergency
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\schemas.py ---
# app/schemas.py

from marshmallow import Schema, fields, validate, validates, ValidationError
from marshmallow_enum import EnumField
from .models import Role, GrievanceStatus, Priority

class UserSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    email = fields.Email(required=True)
    password = fields.Str( load_only=True, validate=validate.Length(min=6), allow_none=True)  # Added password field
    role = EnumField(Role, by_value=True, required=True)
    department_id = fields.Int(allow_none=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

    @validates('name')
    def validate_name(self, value):
        if value is None or value.strip() == '':
            raise ValidationError('Name cannot be empty or null')

class GrievanceSchema(Schema):
    id = fields.Int(dump_only=True)
    complaint_id = fields.Str(dump_only=True)
    title = fields.Str(required=True) # Used for both loading and dumping
    description = fields.Str(required=True) # Used for both loading and dumping

    # --- Fields for LOADING data (API input from user) ---
    subject_id = fields.Int(required=True, load_only=True)
    area_id = fields.Int(required=True, load_only=True)

    # 🔹 Add location fields
    latitude = fields.Float(allow_none=True)
    longitude = fields.Float(allow_none=True)
    address = fields.Str(allow_none=True)

    # --- Fields for DUMPING data (API output) ---
    status = EnumField(GrievanceStatus, by_value=True, dump_only=True)
    priority = EnumField(Priority, by_value=True, allow_none=True,dump_default=Priority.MEDIUM.value)
    rejection_reason = fields.Str(allow_none=True, dump_only=True)
    resolved_at = fields.DateTime(allow_none=True, dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

    # Nested objects for richer API output
    citizen = fields.Nested(UserSchema(only=("id", "name")), dump_only=True, dump_default={'id': 0, 'name': 'Unknown User'})
    subject = fields.Nested('MasterSubjectsSchema', dump_only=True)
    area = fields.Nested('MasterAreasSchema', dump_only=True)
    assignee = fields.Nested(UserSchema(only=("id", "name")), dump_only=True)
    attachments = fields.Nested('GrievanceAttachmentSchema', many=True, dump_only=True)
    comments = fields.Nested('GrievanceCommentSchema', many=True, dump_only=True)
    @validates('citizen')
    def validate_citizen(self, value):
        if value is None:
            return {'id': 0, 'name': 'Unknown User'}
        
class GrievanceAttachmentSchema(Schema):
    id = fields.Int(dump_only=True)
    grievance_id = fields.Int(required=True)
    file_path = fields.Str(dump_only=True)
    file_type = fields.Str(dump_only=True)
    file_size = fields.Int(dump_only=True)  # New field
    uploaded_at = fields.DateTime(dump_only=True)

class GrievanceCommentSchema(Schema):
    id = fields.Int(dump_only=True)
    grievance_id = fields.Int(required=True)
    user_id = fields.Int(dump_only=True)
    comment_text = fields.Str(required=True)
    created_at = fields.DateTime(dump_only=True)
    user = fields.Nested(UserSchema(only=("name",)), dump_only=True)

class WorkproofSchema(Schema):
    id = fields.Int(dump_only=True)
    grievance_id = fields.Int(required=True)
    uploaded_by = fields.Int(dump_only=True)
    file_path = fields.Str(dump_only=True)
    notes = fields.Str(allow_none=True)
    uploaded_at = fields.DateTime(dump_only=True)

class MasterSubjectsSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)

class MasterAreasSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)

class AuditLogSchema(Schema):
    id = fields.Int(dump_only=True)
    action = fields.Str(required=True)
    performed_by = fields.Int(required=True)
    grievance_id = fields.Int(allow_none=True)
    timestamp = fields.DateTime(dump_only=True)

# app/schemas.py
class AnnouncementSchema(Schema):
    id = fields.Int(dump_only=True)
    title = fields.Str(required=True)
    message = fields.Str(required=True)
    type = fields.Str(required=True, validate=validate.OneOf(["general", "emergency"]))
    created_at = fields.DateTime(dump_only=True)

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\__init__.py ---
# app/__init__.py

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_mail import Mail
from .config import Config
from flask_cors import CORS
from .extensions import oauth

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
mail = Mail()
import logging
# oauth is defined in extensions.py

def create_app():
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(__name__)
    app = Flask(__name__)
    
    app.config.from_object(Config)

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    mail.init_app(app)
    oauth.init_app(app)
    cors_origins = ["http://localhost:*", "http://127.0.0.1:*", "http://localhost:5500", "http://127.0.0.1:5500"]
    CORS(app, resources={r"/*": {
        "origins": cors_origins,
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Authorization", "Content-Type"],
        "expose_headers": ["*"],
        "supports_credentials": True
    }})
    logger.debug(f"CORS configured for origins: {', '.join(cors_origins)}")
    # Register Google OAuth client
    oauth.register(
        name='google',
        client_id=app.config.get('GOOGLE_CLIENT_ID'),
        client_secret=app.config.get('GOOGLE_CLIENT_SECRET'),
        server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
        client_kwargs={'scope': 'openid email profile'}
    )

    # Create upload folder if not exists
    import os
    if not os.path.exists(app.config['UPLOAD_FOLDER']):
        os.makedirs(app.config['UPLOAD_FOLDER'])

    # Import and register blueprints
    from .routes.auth_routes import auth_bp
    from .routes.grievance_routes import grievance_bp
    from .routes.user_routes import user_bp
    from .routes.admin_routes import admin_bp
    from .routes.notification_routes import notification_bp
    from .routes.public import public_bp
    app.register_blueprint(public_bp)
    app.register_blueprint(notification_bp, url_prefix='/notifications')

    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(grievance_bp, url_prefix='/grievances')
    app.register_blueprint(user_bp, url_prefix='/users')
    app.register_blueprint(admin_bp, url_prefix='/admins')

    return app

=== Folder: app\routes ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\admin_routes.py ---
# app/routes/admin_routes.py

from flask import Blueprint, request, jsonify
from ..utils.auth_utils import admin_required
from ..utils.kpi_utils import calculate_resolution_rate, calculate_pending_aging, calculate_sla_compliance
from ..models import AuditLog,MasterConfig, MasterSubjects, MasterAreas, Grievance, User, Role, Announcement, NotificationToken
from ..services.report_service import generate_report,get_staff_performance, get_location_reports
from ..services.notification_service import send_notification
from ..services.report_service import get_citizen_history
from ..services.report_service import escalate_grievance
from ..services.report_service import get_advanced_kpis
from datetime import datetime
from ..schemas import GrievanceSchema, UserSchema, AnnouncementSchema
from flask import Response
from ..schemas import AuditLogSchema, MasterSubjectsSchema, MasterAreasSchema
from .. import db
from ..services.grievance_service import reassign_grievance
from ..services.user_service import add_update_user
admin_bp = Blueprint('admin', __name__)

@admin_bp.route('/dashboard', methods=['GET'])
@admin_required
def dashboard(user):
    kpis = {
        'resolution_rate': calculate_resolution_rate(),
        'pending_aging': calculate_pending_aging(),
        'sla_compliance': calculate_sla_compliance()
    }
    return jsonify(kpis), 200

@admin_bp.route('/subjects', methods=['POST'])
@admin_required
def manage_subjects(user):
    data = request.json
    schema = MasterSubjectsSchema()
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    subject = MasterSubjects(**data)
    db.session.add(subject)
    db.session.commit()
    return schema.dump(subject), 201

@admin_bp.route('/areas', methods=['POST'])
@admin_required
def manage_areas(user):
    data = request.json
    schema = MasterAreasSchema()
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    area = MasterAreas(**data)
    db.session.add(area)
    db.session.commit()
    return schema.dump(area), 201

@admin_bp.route('/reassign/<int:id>', methods=['POST'])
@admin_required
def reassign(user, id):
    data = request.json
    result = reassign_grievance(id, data['assigned_to'], user.id)
    return jsonify(result), 200

@admin_bp.route('/audit-logs', methods=['GET', 'OPTIONS'])
@admin_required
def audit_logs(user):
    if request.method == 'OPTIONS':
        return '', 200  # Handle preflight request
    logs = AuditLog.query.all()
    schema = AuditLogSchema(many=True)
    return jsonify(schema.dump(logs)), 200

# Add to existing admin_bp

@admin_bp.route('/kpis/advanced', methods=['GET'])
@admin_required
def advanced_kpis(user):
    return jsonify(get_advanced_kpis()), 200

@admin_bp.route('/reports', methods=['GET'])
@admin_required
def reports(user):
    filter_type = request.args.get('filter', 'all')
    format = request.args.get('format', 'pdf')

    # Your existing function that generates report data
    report_data = generate_report(filter_type, format)

    if format == 'pdf':
        # report_data should be bytes for PDF
        return Response(
            report_data,
            mimetype='application/pdf',
            headers={"Content-Disposition": "attachment; filename=report.pdf"}
        )

    elif format == 'csv':
        # report_data should be a string (CSV text)
        return Response(
            report_data,
            mimetype='text/csv',
            headers={"Content-Disposition": "attachment; filename=report.csv"}
        )

    elif format == 'excel':
        # report_data should be bytes (Excel file content)
        return Response(
            report_data,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            headers={"Content-Disposition": "attachment; filename=report.xlsx"}
        )

    else:
        return {"error": "Invalid format. Supported: pdf, csv, excel"}, 400
@admin_bp.route('/users/<int:id>/history', methods=['GET'])
@admin_required
def citizen_history(user, id):
    history = get_citizen_history(id)
    schema = GrievanceSchema(many=True)
    return jsonify(schema.dump(history)), 200

@admin_bp.route('/grievances/all', methods=['GET'])
@admin_required
def all_grievances(user):
    # Add filters: status=request.args.get('status'), etc.
    grievances = Grievance.query.all()  # Apply filters
    schema = GrievanceSchema(many=True)
    return jsonify(schema.dump(grievances)), 200

@admin_bp.route('/grievances/<int:id>/escalate', methods=['POST'])
@admin_required
def escalate(user, id):
    try:
        data = request.json or {}
        new_assignee_id = data.get('assignee_id')
        result = escalate_grievance(id, user.id, new_assignee_id)
        return jsonify(result), 200 if result["success"] else 400
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@admin_bp.route('/configs', methods=['GET', 'POST' , 'OPTIONS'])
@admin_required
def manage_configs(user):
    if request.method == 'POST' :
        data = request.json
        config = MasterConfig(key=data['key'], value=data['value'])
        db.session.add(config)
        db.session.commit()
    configs = MasterConfig.query.all()
    return jsonify([{'key': c.key, 'value': c.value} for c in configs]), 200

# In app/routes/admin_routes.py
@admin_bp.route('/configs/<string:key>', methods=['PUT'])
@admin_required
def update_config(user, key):
    data = request.json
    config = MasterConfig.query.filter_by(key=key).first()
    if not config:
        return jsonify({"error": "Config not found"}), 404
    config.value = data.get('value')
    config.updated_at = datetime.utcnow()
    db.session.commit()
    return jsonify({'key': config.key, 'value': config.value}), 200

@admin_bp.route('/users/history', methods=['GET'])
@admin_required
def all_users_history(user):
    users = User.query.all()
    result = []
    grievance_schema = GrievanceSchema(many=True)
    for u in users:
        history = get_citizen_history(u.id)
        result.append({
            "user": {
                "id": u.id,
                "name": u.name,
                "email": u.email,
                "role": u.role.value if u.role else None
            },
            "grievances": grievance_schema.dump(history)
        })
    return jsonify(result), 200

@admin_bp.route('/subjects', methods=['GET'])
@admin_required
def list_subjects(user):
    subjects = MasterSubjects.query.all()
    schema = MasterSubjectsSchema(many=True)
    return jsonify(schema.dump(subjects)), 200

@admin_bp.route('/areas', methods=['GET'])
@admin_required
def list_areas(user):
    areas = MasterAreas.query.all()
    schema = MasterAreasSchema(many=True)
    return jsonify(schema.dump(areas)), 200

@admin_bp.route('/users', methods=['GET'])
@admin_required
def list_users(user):
    users = User.query.all()
    schema = UserSchema(many=True, exclude=['password'])  # Exclude sensitive fields
    return jsonify(schema.dump(users)), 200

@admin_bp.route('/users/<int:id>', methods=['PUT'])
@admin_required
def update_user(user, id):
    """Update a specific user by ID."""
    data = request.json
    if 'role' in data:
        try:
            role_mapping = {
                'citizen': Role.CITIZEN,
                'member_head': Role.MEMBER_HEAD,
                'field_staff': Role.FIELD_STAFF,
                'admin': Role.ADMIN
            }
            if data['role'] in role_mapping:
                data['role'] = role_mapping[data['role']]
            else:
                return jsonify({"msg": f"Invalid role: {data['role']}"}), 400
        except Exception as e:
            return jsonify({"msg": f"Error processing role: {str(e)}"}), 400
    
    try:
        result = add_update_user({**data, 'id': id})
        return jsonify(result), 200
    except ValueError as e:
        return jsonify({"msg": str(e)}), 400
    except Exception as e:
        return jsonify({"msg": "Failed to update user", "error": str(e)}), 500
    
@admin_bp.route('/reports/staff-performance', methods=['GET'])
@admin_required
def staff_performance(user):
    return jsonify(get_staff_performance()), 200

@admin_bp.route('/reports/location', methods=['GET'])
@admin_required
def location_reports(user):
    return jsonify(get_location_reports()), 200

@admin_bp.route('/announcements', methods=['POST'])
@admin_required
def create_announcement(user):
    data = request.json
    schema = AnnouncementSchema()
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    
    announcement = Announcement(**data)
    db.session.add(announcement)
    db.session.commit()

    # Broadcast via email/FCM
    users = User.query.all()
    for u in users:
        token = NotificationToken.query.filter_by(user_id=u.id).first()
        send_notification(
            to=u.email,
            subject=f"{data['type'].capitalize()} Announcement",
            body=data['message'],
            fcm_token=token.fcm_token if token else None
        )
    return schema.dump(announcement), 201

@admin_bp.route('/announcements', methods=['GET'])
@admin_required
def list_announcements(user):
    announcements = Announcement.query.order_by(Announcement.created_at.desc()).all()
    schema = AnnouncementSchema(many=True)
    return jsonify(schema.dump(announcements)), 200
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\auth_routes.py ---
# app/routes/auth_routes.py

# app/routes/auth_routes.py

from flask import Blueprint, request, jsonify, redirect, url_for, session, current_app
from flask_jwt_extended import create_access_token, create_refresh_token, get_jwt_identity, jwt_required
from requests_oauthlib.oauth2_session import OAuth2Session
import requests
from ..models import User, Role
from .. import db
from ..schemas import UserSchema
from werkzeug.security import check_password_hash
from ..services.otp_service import send_otp, verify_otp

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.json
    schema = UserSchema()
    try:
        user_data = schema.load(data)
    except Exception as e:
        return jsonify({"msg": "Invalid input", "errors": str(e)}), 400

    if User.query.filter_by(email=user_data['email']).first():
        return jsonify({"msg": "Email already exists"}), 400

    user = User(
        name=user_data['name'],
        email=user_data['email'],
        role=Role.CITIZEN,  # Default to CITIZEN for registration
    )
    user.set_password(data['password'])
    db.session.add(user)
    db.session.commit()

    access_token = create_access_token(identity=str(user.id))
    return jsonify({"access_token": access_token}), 201

@auth_bp.route('/login', methods=['POST'])
def password_login():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    user = User.query.filter_by(email=email).first()
    if not user or not user.check_password(password):
        return jsonify({"msg": "Invalid email or password"}), 401

    access_token = create_access_token(identity=str(user.id))
    return jsonify({"access_token": access_token}), 200

# app/routes/auth_routes.py
@auth_bp.route('/refresh', methods=['POST'])
@jwt_required(refresh=True)
def refresh():
    current_user_id = get_jwt_identity()
    new_access_token = create_access_token(identity=current_user_id)
    new_refresh_token = create_refresh_token(identity=current_user_id)
    return jsonify({
        "access_token": new_access_token,
        "refresh_token": new_refresh_token
    }), 200



@auth_bp.route('/google/login')
def google_login():
    """
    Step 1: Redirects the user to Google's authentication page.
    """
    if not current_app.config.get('GOOGLE_CLIENT_ID') or not current_app.config.get('GOOGLE_CLIENT_SECRET'):
        return jsonify({"msg": "Google OAuth is not configured on the server."}), 500

    try:
        google_discovery_doc = requests.get(current_app.config['GOOGLE_DISCOVERY_URL']).json()
        authorization_endpoint = google_discovery_doc.get("authorization_endpoint")
    except requests.exceptions.RequestException as e:
        return jsonify({"msg": "Could not connect to Google's discovery service.", "error": str(e)}), 500

    oauth_session = OAuth2Session(
        client_id=current_app.config['GOOGLE_CLIENT_ID'],
        redirect_uri=url_for('auth.google_callback', _external=True),
        scope=["openid", "email", "profile"]
    )

    authorization_url, state = oauth_session.authorization_url(authorization_endpoint)
    session['oauth_state'] = state
    return redirect(authorization_url)

@auth_bp.route('/google/callback')
def google_callback():
    if not current_app.config.get('GOOGLE_CLIENT_ID') or not current_app.config.get('GOOGLE_CLIENT_SECRET'):
        return jsonify({"msg": "Google OAuth is not configured on the server."}), 500

    try:
        google_discovery_doc = requests.get(current_app.config['GOOGLE_DISCOVERY_URL']).json()
        token_endpoint = google_discovery_doc.get("token_endpoint")
        userinfo_endpoint = google_discovery_doc.get("userinfo_endpoint")
    except requests.exceptions.RequestException as e:
        return jsonify({"msg": "Could not connect to Google's discovery service.", "error": str(e)}), 500

    oauth_session = OAuth2Session(
        client_id=current_app.config['GOOGLE_CLIENT_ID'],
        state=session.get('oauth_state'),
        redirect_uri=url_for('auth.google_callback', _external=True)
    )

    try:
        token = oauth_session.fetch_token(
            token_endpoint,
            client_secret=current_app.config['GOOGLE_CLIENT_SECRET'],
            authorization_response=request.url
        )
    except Exception as e:
        return jsonify({"msg": "Failed to fetch token from Google.", "error": str(e)}), 400

    user_info = oauth_session.get(userinfo_endpoint).json()
    email, name = user_info.get('email'), user_info.get('name')

    user = User.query.filter_by(email=email).first()
    if not user:
        user = User(name=name, email=email, role=Role.CITIZEN)
        db.session.add(user)
        db.session.commit()

    access_token = create_access_token(identity=str(user.id))
    frontend_callback_url = f"http://localhost:5500/login/callback?access_token={access_token}"
    return redirect(frontend_callback_url)

@auth_bp.route('/logout', methods=['POST'])
def logout():
    return jsonify({"msg": "Logout successful"}), 200

@auth_bp.route('/me', methods=['GET'])
@jwt_required()
def get_current_user():
    user_id = get_jwt_identity()
    user = User.query.get(int(user_id))   # convert back to int
    if not user:
        return jsonify({"msg": "User not found"}), 404
    schema = UserSchema()
    return jsonify(schema.dump(user)), 200

@auth_bp.route('/otp/send', methods=['POST'])
def send_otp():
    data = request.json
    phone_number = data.get('phone_number')
    if not phone_number:
        return jsonify({"msg": "Phone number required"}), 400
    return jsonify(send_otp(phone_number)), 200

@auth_bp.route('/otp/verify', methods=['POST'])
def verify_otp_route():
    data = request.json
    phone_number = data.get('phone_number')
    otp = data.get('otp')

    if verify_otp(phone_number, otp):
        user = User.query.filter_by(phone_number=phone_number).first()
        if not user:
            # ✅ Auto-register new user if first OTP login
            user = User(phone_number=phone_number, role=Role.CITIZEN, name="Guest User")
            db.session.add(user)
            db.session.commit()

        access_token = create_access_token(identity=str(user.id))
        refresh_token = create_refresh_token(identity=str(user.id))
        return jsonify({"access_token": access_token, "refresh_token": refresh_token}), 200
    
    return jsonify({"msg": "Invalid or expired OTP"}), 401

@auth_bp.route('/guest-login', methods=['POST'])
def guest_login():
    """
    Allows users to login as Guest with limited access (read-only).
    """
    guest_user = User(name="Guest User", role=Role.CITIZEN)
    db.session.add(guest_user)
    db.session.commit()

    access_token = create_access_token(identity=str(guest_user.id))
    refresh_token = create_refresh_token(identity=str(guest_user.id))
    return jsonify({
        "access_token": access_token,
        "refresh_token": refresh_token,
        "msg": "Logged in as Guest"
    }), 200

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\grievance_routes.py ---
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from ..utils.auth_utils import citizen_required, jwt_required_with_role, admin_required, member_head_required, field_staff_required
from ..models import Grievance, GrievanceStatus, Role, User, GrievanceComment, MasterConfig
from ..schemas import GrievanceSchema, GrievanceCommentSchema
from ..services.grievance_service import (
    submit_grievance, get_my_grievances, get_grievance_details,
    add_comment, confirm_closure, get_rejection_reason,
    get_new_grievances, accept_grievance, reject_grievance,
    get_assigned_grievances, update_status, upload_workproof,
    escalate_grievance
)
from ..services.notification_service import send_notification
from .. import db
from ..services.grievance_service import log_audit
from datetime import datetime

grievance_bp = Blueprint('grievances', __name__)

@grievance_bp.route('/', methods=['POST'])
@citizen_required
def create_grievance(user):
    try:
        data = request.form.to_dict()
        files = request.files.getlist('files')
        
        # Set default priority if not provided
        if 'priority' not in data or not data['priority']:
            default_priority = MasterConfig.query.filter_by(key='DEFAULT_PRIORITY').first()
            data['priority'] = default_priority.value if default_priority else 'medium'

        # Ensure lat/lng passed as float
        if "latitude" in data and data["latitude"]:
            data["latitude"] = float(data["latitude"])
        if "longitude" in data and data["longitude"]:
            data["longitude"] = float(data["longitude"])

        result = submit_grievance(user.id, data, files)
        log_audit(f"Grievance created by user {user.id}", user.id, result.get('id'))
        return jsonify(result), 201
    except Exception as e:
        current_app.logger.error(f"Error creating grievance: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/mine', methods=['GET'])
@citizen_required
def my_grievances(user):
    try:
        result = get_my_grievances(user.id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching grievances for user {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>', methods=['GET'])
@jwt_required_with_role([Role.CITIZEN, Role.MEMBER_HEAD, Role.FIELD_STAFF, Role.ADMIN])
def get_grievance(user, id):
    current_app.logger.info(f"Fetching grievance ID {id} for user ID {user.id} with role {user.role}")
    grievance = db.session.get(Grievance, id)
    if not grievance:
        current_app.logger.error(f"Grievance ID {id} not found")
        return jsonify({"msg": "Grievance not found"}), 404
    schema = GrievanceSchema()
    current_app.logger.info(f"Grievance found: {schema.dump(grievance)}")
    return jsonify(schema.dump(grievance)), 200

@grievance_bp.route('/<int:id>/comments', methods=['POST'])
@citizen_required
def add_grievance_comment(user, id):
    try:
        data = request.get_json()
        comment_text = data.get('comment_text')
        if not comment_text:
            return jsonify({"msg": "Comment text is required"}), 400
        result = add_comment(id, user.id, comment_text)
        log_audit(f"Comment added to grievance {id}", user.id, id)
        return jsonify(result), 201
    except Exception as e:
        current_app.logger.error(f"Error adding comment to grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/close', methods=['POST'])
@citizen_required
def close_grievance(user, id):
    try:
        result = confirm_closure(id, user.id)
        log_audit(f"Grievance {id} closed by user {user.id}", user.id, id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error closing grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/rejection', methods=['GET'])
@citizen_required
def rejection_reason(user, id):
    try:
        reason = get_rejection_reason(id, user.id)
        return jsonify({"rejection_reason": reason}), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching rejection reason for grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/new', methods=['GET'])
@member_head_required
def new_grievances(user):
    try:
        result = get_new_grievances(user.department_id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching new grievances for department {user.department_id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/accept', methods=['POST'])
@member_head_required
def accept(user, id):
    try:
        data = request.get_json()
        result = accept_grievance(id, user.id, data)
        log_audit(f"Grievance {id} accepted by user {user.id}", user.id, id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error accepting grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/reject', methods=['POST'])
@member_head_required
def reject(user, id):
    try:
        data = request.get_json()
        reason = data.get('reason')
        if not reason:
            return jsonify({"msg": "Rejection reason is required"}), 400
        result = reject_grievance(id, user.id, reason)
        log_audit(f"Grievance {id} rejected by user {user.id}", user.id, id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error rejecting grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/assigned', methods=['GET'])
@field_staff_required
def assigned_grievances(user):
    try:
        result = get_assigned_grievances(user.id)
        return jsonify(result), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching assigned grievances for user {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/status', methods=['PUT'])
@field_staff_required
def update_grievance_status(user, id):
    data = request.json
    new_status = data.get('status')
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance:
            return jsonify({"error": "Grievance not found"}), 404
        if grievance.assigned_to != user.id:
            return jsonify({"error": "Not authorized to update this grievance"}), 403
        old_status = grievance.status
        grievance.status = GrievanceStatus[new_status.upper()]
        if grievance.status == GrievanceStatus.RESOLVED:
            grievance.resolved_at = datetime.utcnow()
        db.session.commit()
        log_audit(f'Status updated from {old_status} to {grievance.status}', user.id, id)
        send_notification(
            grievance.citizen.email,
            'Status Updated',
            f'Your grievance #{id} status is now {new_status}.'
        )
        schema = GrievanceSchema()
        return jsonify(schema.dump(grievance)), 200
    except ValueError as e:
        current_app.logger.error(f"Invalid status value for grievance {id}: {str(e)}")
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Failed to update status for grievance {id}: {str(e)}")
        return jsonify({"error": f"Failed to update status: {str(e)}"}), 500

@grievance_bp.route('/<int:id>/workproof', methods=['POST'])
@field_staff_required
def upload_grievance_workproof(user, id):
    try:
        file = request.files.get('file')
        if not file:
            return jsonify({"msg": "File is required"}), 400
        data = request.form
        result = upload_workproof(id, user.id, file, data.get('notes'))
        log_audit(f"Workproof uploaded for grievance {id}", user.id, id)
        return jsonify(result), 201
    except Exception as e:
        current_app.logger.error(f"Error uploading workproof for grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/feedback', methods=['POST'])
@citizen_required
def submit_feedback(user, id):
    try:
        grievance = Grievance.query.get_or_404(id)
        if grievance.citizen_id != user.id or grievance.status != GrievanceStatus.RESOLVED:
            return jsonify({"msg": "Invalid operation: Grievance must be resolved and owned by user"}), 400
        data = request.get_json()
        rating = data.get('rating')
        if not rating or not isinstance(rating, int) or rating < 1 or rating > 5:
            return jsonify({"msg": "Valid rating (1-5) is required"}), 400
        grievance.feedback_rating = rating
        grievance.feedback_text = data.get('feedback_text')
        db.session.commit()
        log_audit(f"Feedback submitted for grievance {id}", user.id, id)
        return jsonify({"msg": "Feedback submitted successfully"}), 200
    except Exception as e:
        current_app.logger.error(f"Error submitting feedback for grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/admin/<int:id>', methods=['GET'])
@admin_required
def get_grievance_admin(user, id):
    try:
        grievance = Grievance.query.get_or_404(id)
        schema = GrievanceSchema()
        return jsonify(schema.dump(grievance)), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching grievance {id} for admin: {str(e)}")
        return jsonify({"msg": str(e)}), 404

@grievance_bp.route('/admin/grievances/all', methods=['GET'])
@admin_required
def get_all_grievances(user):
    try:
        grievances = Grievance.query.all()
        schema = GrievanceSchema(many=True)
        log_audit(f"Admin {user.id} fetched all grievances", user.id, None)
        return jsonify(schema.dump(grievances)), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching all grievances for admin {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/reassign', methods=['PUT'])
@admin_required
def reassign_grievance(user, id):
    try:
        data = request.get_json()
        assignee_id = data.get('assignee_id')
        if not assignee_id:
            return jsonify({"msg": "Assignee ID is required"}), 400
        grievance = Grievance.query.get_or_404(id)
        assignee = User.query.get_or_404(assignee_id)
        if assignee.role != Role.FIELD_STAFF:
            return jsonify({"msg": "Assignee must have field staff role"}), 400
        grievance.assigned_to = assignee_id
        db.session.commit()
        log_audit(f"Grievance {id} reassigned to user {assignee_id}", user.id, id)
        return jsonify({"msg": "Grievance reassigned successfully"}), 200
    except Exception as e:
        current_app.logger.error(f"Error reassigning grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/<int:id>/escalate', methods=['POST'])
@admin_required
def escalate_grievance(user, id):
    try:
        result = escalate_grievance(id, user.id)
        log_audit(f"Grievance {id} escalated by user {user.id}", user.id, id)
        return jsonify(result), 200 if result['success'] else 404
    except Exception as e:
        current_app.logger.error(f"Error escalating grievance {id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400

@grievance_bp.route('/search/<string:complaint_id>', methods=['GET'])
@jwt_required_with_role([Role.CITIZEN, Role.MEMBER_HEAD, Role.FIELD_STAFF, Role.ADMIN])
def search_grievance_by_complaint_id(user, complaint_id):
    try:
        grievance = Grievance.query.filter_by(complaint_id=complaint_id).first()
        if not grievance:
            current_app.logger.error(f"Grievance with complaint ID {complaint_id} not found")
            return jsonify({"msg": "Grievance not found"}), 404
        schema = GrievanceSchema()
        return jsonify(schema.dump(grievance)), 200
    except Exception as e:
        current_app.logger.error(f"Error searching grievance by complaint ID {complaint_id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400
    

@grievance_bp.route('/track', methods=['GET'])
@jwt_required_with_role([Role.CITIZEN])
def track_grievances(user):
    try:
        current_app.logger.info(f"Track grievances called for user ID {user.id}")
        grievances = Grievance.query.filter_by(citizen_id=user.id).all()
        schema = GrievanceSchema(many=True)
        
        grievances_data = schema.dump(grievances)
        for grievance in grievances_data:
            # Ensure no null values in critical fields
            grievance['id'] = grievance.get('id') or 0
            grievance['citizen_id'] = grievance.get('citizen_id') or user.id
            grievance['subject_id'] = grievance.get('subject_id') or 0
            grievance['area_id'] = grievance.get('area_id') or 0
            grievance['title'] = grievance.get('title') or 'Untitled Grievance'
            grievance['description'] = grievance.get('description') or 'No description provided'
            grievance['complaint_id'] = grievance.get('complaint_id') or str(uuid.uuid4())[:8]
            grievance['citizen'] = grievance.get('citizen') or {'id': 0, 'name': 'Unknown User'}
            grievance['assignee'] = grievance.get('assignee') or {'id': 0, 'name': 'Unassigned'}
            if grievance.get('assigned_to') is None:
                grievance['assigned_to'] = 0
        
        return jsonify(grievances_data), 200
    except Exception as e:
        current_app.logger.error(f"Error tracking grievances for user {user.id}: {str(e)}")
        return jsonify({"msg": str(e)}), 400
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\notification_routes.py ---
from flask import Blueprint, request, jsonify
from ..services.notification_service import register_fcm_token
from flask_jwt_extended import jwt_required


notification_bp = Blueprint('notification', __name__)

@notification_bp.route('/register', methods=['POST'])
@jwt_required
def register_notification_token(user):
    data = request.json
    fcm_token = data.get('fcm_token')
    if not fcm_token:
        return jsonify({"msg": "FCM token required"}), 400
    register_fcm_token(user.id, fcm_token)
    return jsonify({"msg": "FCM token registered"}), 200
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\public.py ---
# app/routes/public.py (create if it doesn't exist)
from flask import Blueprint, jsonify
from ..models import MasterSubjects, MasterAreas
from .. import db

public_bp = Blueprint('public', __name__)

@public_bp.route('/subjects', methods=['GET'])
def get_subjects():
    subjects = MasterSubjects.query.all()
    return jsonify([{'id': s.id, 'name': s.name, 'description': s.description} for s in subjects])

@public_bp.route('/areas', methods=['GET'])
def get_areas():
    areas = MasterAreas.query.all()
    return jsonify([{'id': a.id, 'name': a.name, 'description': a.description} for a in areas])
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\routes\user_routes.py ---
# app/routes/user_routes.py

from flask import Blueprint, request, jsonify
from ..utils.auth_utils import admin_required, citizen_required, get_jwt_identity
from ..services.user_service import add_update_user
from ..models import User,Role, Grievance
from ..schemas import GrievanceSchema
from ..schemas import UserSchema
from .. import db

user_bp = Blueprint('user', __name__)

@user_bp.route('/', methods=['GET'] , endpoint='user_list')
@admin_required
def get_users(user):
    """Retrieve all users."""
    try:
        users = User.query.all()
        schema = UserSchema(many=True)
        return jsonify(schema.dump(users)), 200
    except Exception as e:
        return jsonify({"msg": "Failed to retrieve users", "error": str(e)}), 500

@user_bp.route('/<int:id>', methods=['GET'])
@admin_required
def get_user2(user, id):
    """Retrieve a specific user by ID."""
    try:
        user = User.query.get(id)
        if not user:
            return jsonify({"msg": "User not found"}), 404
        schema = UserSchema()
        return jsonify(schema.dump(user)), 200
    except Exception as e:
        return jsonify({"msg": "Failed to retrieve user", "error": str(e)}), 500



@user_bp.route('/admin/users', methods=['GET'])
@admin_required
def get_users(user):
    """Retrieve all users."""
    try:
        users = User.query.all()
        schema = UserSchema(many=True, exclude=['password'])
        return jsonify(schema.dump(users)), 200
    except Exception as e:
        return jsonify({"msg": "Failed to retrieve users", "error": str(e)}), 500



# Keep your other routes but update the URLs to match
@user_bp.route('/admin/users', methods=['POST'])
@admin_required
def manage_user(user):
    """Add a new user."""
    data = request.json
    
    # Convert role string to Role enum
    if 'role' in data:
        try:
            role_mapping = {
                'citizen': Role.CITIZEN,
                'member_head': Role.MEMBER_HEAD,
                'field_staff': Role.FIELD_STAFF,
                'admin': Role.ADMIN
            }
            if data['role'] in role_mapping:
                data['role'] = role_mapping[data['role']]
            else:
                return jsonify({"msg": f"Invalid role: {data['role']}"}), 400
        except Exception as e:
            return jsonify({"msg": f"Error processing role: {str(e)}"}), 400
    
    try:
        result = add_update_user(data)
        return jsonify(result), 201
    except ValueError as e:
        return jsonify({"msg": str(e)}), 400
    except Exception as e:
        return jsonify({"msg": "An error occurred", "error": str(e)}), 500

@user_bp.route('/admin/users/<int:id>', methods=['DELETE'])
@admin_required
def delete_user(user, id):
    """Delete a specific user by ID."""
    try:
        user_to_delete = User.query.get(id)
        if not user_to_delete:
            return jsonify({"msg": "User not found"}), 404
        db.session.delete(user_to_delete)
        db.session.commit()
        return jsonify({"msg": "User deleted successfully"}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({"msg": "Failed to delete user", "error": str(e)}), 500
    


=== Folder: app\routes\__pycache__ ===


=== Folder: app\services ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\grievance_service.py ---
from datetime import datetime, timedelta
from flask import current_app
from marshmallow import ValidationError
from ..models import Grievance, GrievanceAttachment, GrievanceComment, Workproof, GrievanceStatus, Priority, AuditLog, User, NotificationToken, Role
from ..schemas import GrievanceSchema, GrievanceAttachmentSchema, GrievanceCommentSchema, WorkproofSchema
from ..utils.file_utils import upload_files, upload_workproof
from .. import db
from ..config import Config
from .notification_service import send_notification
from flask_jwt_extended import get_jwt_identity

def submit_grievance(citizen_id, data, files):
    try:
        schema = GrievanceSchema()
        try:
            validated_data = schema.load(data)
        except ValidationError as err:
            current_app.logger.error(f"Validation error in submit_grievance: {err.messages}")
            raise ValueError(f"Invalid grievance data: {err.messages}")

        # Create grievance, letting the model handle default priority if not provided
        grievance = Grievance(
            citizen_id=citizen_id,
            subject_id=validated_data['subject_id'],
            area_id=validated_data['area_id'],
            title=validated_data['title'],
            description=validated_data['description'],
            latitude=validated_data.get('latitude'),
            longitude=validated_data.get('longitude'),
            address=validated_data.get('address'),
            status=GrievanceStatus.NEW,
            priority=validated_data.get('priority', Priority.MEDIUM)  # ← Use validated_data or default
        )
        db.session.add(grievance)
        db.session.flush()  # Get grievance ID before committing

        if files:
            try:
                uploaded = upload_files(files, grievance.id)
                for path, typ, size in uploaded:
                    attachment = GrievanceAttachment(
                        grievance_id=grievance.id,
                        file_path=path,
                        file_type=typ,
                        file_size=size
                    )
                    db.session.add(attachment)
            except ValueError as e:
                db.session.rollback()
                current_app.logger.error(f"File upload failed for grievance {grievance.id}: {str(e)}")
                raise ValueError(f"File upload error: {str(e)}")

        db.session.commit()

        log_audit(f'Grievance created (Complaint ID {grievance.complaint_id})', citizen_id, grievance.id)

        token = NotificationToken.query.filter_by(user_id=citizen_id).first()
        send_notification(
            grievance.citizen.email,
            'Grievance Submitted',
            'Your grievance has been submitted.',
            fcm_token=token.fcm_token if token else None
        )
        return schema.dump(grievance)
    except ValidationError as e:
        current_app.logger.error(f"Validation error in submit_grievance: {str(e.messages)}")
        raise ValueError(f"Invalid grievance data: {str(e.messages)}")
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error submitting grievance for citizen {citizen_id}: {str(e)}")
        raise ValueError(f"File upload error: {str(e)}")

        db.session.commit()

        log_audit(f'Grievance created (Complaint ID {grievance.complaint_id})', citizen_id, grievance.id)

        token = NotificationToken.query.filter_by(user_id=citizen_id).first()
        send_notification(
            grievance.citizen.email,
            'Grievance Submitted',
            'Your grievance has been submitted.',
            fcm_token=token.fcm_token if token else None
        )
        return schema.dump(grievance)
    except ValidationError as e:
        current_app.logger.error(f"Validation error in submit_grievance: {str(e.messages)}")
        raise ValueError(f"Invalid grievance data: {str(e.messages)}")
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error submitting grievance for citizen {citizen_id}: {str(e)}")
        raise

def get_my_grievances(citizen_id):
    try:
        grievances = Grievance.query.filter_by(citizen_id=citizen_id).all()
        schema = GrievanceSchema(many=True)
        return schema.dump(grievances)
    except Exception as e:
        current_app.logger.error(f"Error fetching grievances for citizen {citizen_id}: {str(e)}")
        raise

def get_grievance_details(id, user_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance:
            current_app.logger.error(f"Grievance {id} not found")
            return None

        user = db.session.get(User, user_id)
        if not user:
            current_app.logger.error(f"User {user_id} not found")
            return None

        if user.role != Role.ADMIN and grievance.citizen_id != user_id:
            current_app.logger.error(f"User {user_id} not authorized to view grievance {id}")
            return None

        _check_auto_close(grievance)
        schema = GrievanceSchema()
        return schema.dump(grievance)
    except Exception as e:
        current_app.logger.error(f"Error fetching grievance details for ID {id}: {str(e)}")
        raise

def add_comment(id, user_id, text):
    try:
        comment = GrievanceComment(grievance_id=id, user_id=user_id, comment_text=text)
        db.session.add(comment)
        db.session.commit()
        schema = GrievanceCommentSchema()
        return schema.dump(comment)
    except Exception as e:
        current_app.logger.error(f"Error adding comment to grievance {id}: {str(e)}")
        raise

def confirm_closure(id, citizen_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.citizen_id != citizen_id or grievance.status != GrievanceStatus.RESOLVED:
            current_app.logger.error(f"Invalid closure attempt for grievance {id} by citizen {citizen_id}")
            raise ValueError("Invalid operation")
        grievance.status = GrievanceStatus.CLOSED
        grievance.updated_at = datetime.utcnow()
        db.session.commit()
        log_audit('Grievance closed', citizen_id, id)
        send_notification(grievance.citizen.email, 'Grievance Closed', 'Your grievance has been closed.')
        return {"msg": "Closed"}
    except Exception as e:
        current_app.logger.error(f"Error closing grievance {id}: {str(e)}")
        raise

def get_rejection_reason(id, citizen_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.citizen_id != citizen_id or grievance.status != GrievanceStatus.REJECTED:
            current_app.logger.error(f"Invalid rejection reason request for grievance {id} by citizen {citizen_id}")
            raise ValueError("Invalid operation")
        return grievance.rejection_reason
    except Exception as e:
        current_app.logger.error(f"Error fetching rejection reason for grievance {id}: {str(e)}")
        raise

def get_new_grievances(department_id):
    try:
        grievances = Grievance.query.filter_by(status=GrievanceStatus.NEW, area_id=department_id).all()
        schema = GrievanceSchema(many=True)
        return schema.dump(grievances)
    except Exception as e:
        current_app.logger.error(f"Error fetching new grievances for department {department_id}: {str(e)}")
        raise

def accept_grievance(id, head_id, data):
    try:
        current_user_id = get_jwt_identity()
        head_user = db.session.get(User, current_user_id)
        grievance = db.session.get(Grievance, id)

        if not grievance or grievance.status != GrievanceStatus.NEW or grievance.area_id != head_user.department_id:
            current_app.logger.error(f"Invalid accept attempt for grievance {id} by user {head_id}")
            raise ValueError("Invalid operation")
        grievance.priority = Priority[data['priority']]
        grievance.assigned_to = data['assigned_to']
        grievance.assigned_by = head_id
        grievance.status = GrievanceStatus.IN_PROGRESS
        db.session.commit()
        log_audit('Grievance accepted and assigned', head_id, id)
        send_notification(grievance.citizen.email, 'Grievance Accepted', 'Your grievance has been accepted.')
        return {"msg": "Accepted"}
    except Exception as e:
        current_app.logger.error(f"Error accepting grievance {id}: {str(e)}")
        raise

def reject_grievance(id, head_id, reason):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.status != GrievanceStatus.NEW or grievance.area_id != db.session.get(User, head_id).department_id:
            current_app.logger.error(f"Invalid reject attempt for grievance {id} by user {head_id}")
            raise ValueError("Invalid operation")
        grievance.status = GrievanceStatus.REJECTED
        grievance.rejection_reason = reason
        db.session.commit()
        log_audit('Grievance rejected', head_id, id)
        send_notification(grievance.citizen.email, 'Grievance Rejected', f'Your grievance has been rejected: {reason}')
        return {"msg": "Rejected"}
    except Exception as e:
        current_app.logger.error(f"Error rejecting grievance {id}: {str(e)}")
        raise

def get_assigned_grievances(employer_id):
    try:
        grievances = Grievance.query.filter_by(assigned_to=employer_id).all()
        schema = GrievanceSchema(many=True)
        return schema.dump(grievances)
    except Exception as e:
        current_app.logger.error(f"Error fetching assigned grievances for user {employer_id}: {str(e)}")
        raise

def update_status(id, employer_id, new_status):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.assigned_to != employer_id:
            current_app.logger.error(f"Invalid status update attempt for grievance {id} by user {employer_id}")
            raise ValueError("Invalid operation")
        old_status = grievance.status
        grievance.status = GrievanceStatus[new_status.upper()]
        if grievance.status == GrievanceStatus.RESOLVED:
            grievance.resolved_at = datetime.utcnow()
        db.session.commit()
        log_audit(f'Status updated from {old_status} to {grievance.status}', employer_id, id)
        send_notification(grievance.citizen.email, 'Status Updated', f'Your grievance status is now {new_status}.')
        return {"msg": "Status updated"}
    except Exception as e:
        current_app.logger.error(f"Error updating status for grievance {id}: {str(e)}")
        raise

def upload_workproof(id, employer_id, file, notes):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance or grievance.assigned_to != employer_id:
            current_app.logger.error(f"Invalid workproof upload attempt for grievance {id} by user {employer_id}")
            raise ValueError("Invalid operation")
        path = upload_workproof(file, id)
        workproof = Workproof(grievance_id=id, uploaded_by=employer_id, file_path=path, notes=notes)
        db.session.add(workproof)
        db.session.commit()
        schema = WorkproofSchema()
        return schema.dump(workproof)
    except Exception as e:
        current_app.logger.error(f"Error uploading workproof for grievance {id}: {str(e)}")
        raise

def reassign_grievance(id, new_assigned_to, admin_id):
    try:
        grievance = db.session.get(Grievance, id)
        if not grievance:
            current_app.logger.error(f"Grievance {id} not found for reassignment")
            raise ValueError("Grievance not found")
        grievance.assigned_to = new_assigned_to
        db.session.commit()
        log_audit('Grievance reassigned', admin_id, id)
        return {"msg": "Reassigned"}
    except Exception as e:
        current_app.logger.error(f"Error reassigning grievance {id}: {str(e)}")
        raise

def log_audit(action, user_id, grievance_id=None):
    try:
        log = AuditLog(action=action, performed_by=user_id, grievance_id=grievance_id)
        db.session.add(log)
        db.session.commit()
    except Exception as e:
        current_app.logger.error(f"Error logging audit for action {action}: {str(e)}")
        raise

def _check_auto_close(grievance):
    try:
        if grievance.status == GrievanceStatus.RESOLVED and grievance.resolved_at:
            sla_days = int(Config.SLA_CLOSURE_DAYS) if hasattr(Config, 'SLA_CLOSURE_DAYS') else 7
            if datetime.utcnow() - grievance.resolved_at > timedelta(days=sla_days):
                grievance.status = GrievanceStatus.CLOSED
                db.session.commit()
                log_audit('Auto-closed due to SLA', grievance.assigned_to, grievance.id)
                send_notification(grievance.citizen.email, 'Grievance Auto-Closed', 'Your grievance has been auto-closed.')
    except Exception as e:
        current_app.logger.error(f"Error checking auto-close for grievance {grievance.id}: {str(e)}")
        raise

def escalate_grievance(grievance_id, escalated_by, new_assignee_id=None):
    MAX_ESCALATION_LEVEL = 3
    ESCALATION_FLOW = {
        0: "Assigned Staff",
        1: "Member Head",
        2: "Admin",
        3: "Super Admin"
    }
    try:
        grievance = db.session.get(Grievance, grievance_id)
        if not grievance:
            current_app.logger.error(f"Grievance {grievance_id} not found for escalation")
            raise ValueError("Grievance not found")

        if grievance.escalation_level >= MAX_ESCALATION_LEVEL:
            current_app.logger.error(f"Grievance {grievance_id} already at maximum escalation level")
            return {"success": False, "msg": "Already at maximum escalation level"}

        grievance.escalation_level += 1

        if new_assignee_id:
            new_assignee = db.session.get(User, new_assignee_id)
            if not new_assignee:
                current_app.logger.error(f"New assignee {new_assignee_id} not found")
                raise ValueError("New assignee not found")
            grievance.assigned_to = new_assignee_id
            grievance.assigned_by = escalated_by

        grievance.updated_at = datetime.utcnow()
        db.session.commit()

        log_audit(
            f"Grievance {grievance_id} escalated to level {grievance.escalation_level}",
            escalated_by,
            grievance_id
        )

        send_notification(
            grievance.citizen.email,
            "Grievance Escalated",
            f"Your grievance #{grievance.id} has been escalated to {ESCALATION_FLOW.get(grievance.escalation_level, 'higher authority')}."
        )
        if grievance.assigned_to:
            assignee = db.session.get(User, grievance.assigned_to)
            if assignee:
                send_notification(
                    assignee.email,
                    "New Escalated Grievance Assigned",
                    f"You have been assigned an escalated grievance #{grievance.id}."
                )

        return {"success": True, "msg": f" Escalated to level {grievance.escalation_level}"}
    except Exception as e:
        current_app.logger.error(f"Error escalating grievance {grievance_id}: {str(e)}")
        raise
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\notification_service.py ---
from flask_mail import Message
from .. import mail
import firebase_admin
from firebase_admin import messaging
from ..models import NotificationToken
from .. import db

def initialize_fcm():
    if not firebase_admin._apps:
        cred = firebase_admin.credentials.Certificate(os.environ.get('FIREBASE_CREDENTIALS'))
        firebase_admin.initialize_app(cred)

def send_notification(to, subject, body, fcm_token=None):
    msg = Message(subject, recipients=[to])
    msg.body = body
    mail.send(msg)

    if fcm_token:
        initialize_fcm()
        message = messaging.Message(
            notification=messaging.Notification(title=subject, body=body),
            token=fcm_token
        )
        messaging.send(message)

def register_fcm_token(user_id, fcm_token):
    token = NotificationToken(user_id=user_id, fcm_token=fcm_token)
    db.session.add(token)
    db.session.commit()
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\otp_service.py ---
from twilio.rest import Client
import random
from .. import db
from ..models import OtpToken
from datetime import datetime, timedelta
import os

def send_otp(phone_number):
    client = Client(os.environ.get('TWILIO_SID'), os.environ.get('TWILIO_AUTH_TOKEN'))
    otp = str(random.randint(100000, 999999))
    message = client.messages.create(
        body=f"Your OTP for Nivaran is {otp}. Valid for 5 minutes.",
        from_=os.environ.get('TWILIO_PHONE_NUMBER'),
        to=phone_number
    )
    otp_token = OtpToken(phone_number=phone_number, otp=otp, expires_at=datetime.utcnow() + timedelta(minutes=5))
    db.session.add(otp_token)
    db.session.commit()
    return {"msg": "OTP sent"}

def verify_otp(phone_number, otp):
    token = OtpToken.query.filter_by(phone_number=phone_number, otp=otp).first()
    if token and token.expires_at > datetime.utcnow():
        db.session.delete(token)
        db.session.commit()
        return True
    return False
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\report_service.py ---

# app/services/report_service.py
import pandas as pd
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from io import BytesIO
from sqlalchemy import func, and_
from datetime import datetime, timedelta
from flask import current_app
from sqlalchemy import func, case
from ..models import Grievance, GrievanceStatus, User, MasterAreas, AuditLog, Role
from .. import db
from .notification_service import send_notification

def generate_report(filter_type='all', format='pdf', user_id=None, area_id=None):
    """
    Generate reports in various formats with filtering options.

    Args:
        filter_type (str): Time period filter ('all', 'day', 'week', 'month', 'year').
        format (str): Output format ('csv', 'excel', 'pdf').
        user_id (int, optional): Filter by specific user ID.
        area_id (int, optional): Filter by specific area ID.

    Returns:
        bytes: Report content in the requested format.

    Raises:
        ValueError: If filter_type or format is invalid.
    """
    valid_filters = ['all', 'day', 'week', 'month', 'year']
    valid_formats = ['csv', 'excel', 'pdf']
    if filter_type not in valid_filters:
        raise ValueError(f"Invalid filter_type. Must be one of {valid_filters}")
    if format not in valid_formats:
        raise ValueError(f"Invalid format. Must be one of {valid_formats}")

    # Build query based on filters
    query = Grievance.query
    
    # Apply time filters
    now = datetime.utcnow()
    if filter_type == 'day':
        query = query.filter(Grievance.created_at >= now - timedelta(days=1))
    elif filter_type == 'week':
        query = query.filter(Grievance.created_at >= now - timedelta(weeks=1))
    elif filter_type == 'month':
        query = query.filter(Grievance.created_at >= now - timedelta(days=30))
    elif filter_type == 'year':
        query = query.filter(Grievance.created_at >= now - timedelta(days=365))
    
    # Apply user filter
    if user_id:
        query = query.filter(Grievance.citizen_id == user_id)
    
    # Apply area filter
    if area_id:
        query = query.filter(Grievance.area_id == area_id)
    
    # Execute query and convert to DataFrame
    try:
        data = pd.read_sql(query.statement, db.engine)
    except Exception as e:
        raise Exception(f"Failed to fetch grievance data: {str(e)}")
    
    # Generate report in requested format
    if format == 'csv':
        return data.to_csv(index=False).encode('utf-8')
    
    elif format == 'excel':
        output = BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            data.to_excel(writer, index=False, sheet_name='Grievance Report')
            # Add summary statistics
            summary_data = get_summary_statistics(query)
            summary_df = pd.DataFrame(list(summary_data.items()), columns=['Metric', 'Value'])
            summary_df.to_excel(writer, index=False, sheet_name='Summary')
        return output.getvalue()
    
    elif format == 'pdf':
        return generate_pdf_report(data, filter_type, user_id, area_id)
    
    return None

def generate_pdf_report(data, filter_type, user_id, area_id):
    """
    Generate a detailed PDF report.

    Args:
        data (pd.DataFrame): Grievance data.
        filter_type (str): Time period filter.
        user_id (int, optional): User ID filter.
        area_id (int, optional): Area ID filter.

    Returns:
        bytes: PDF content.
    """
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    elements = []
    styles = getSampleStyleSheet()
    
    # Add title
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1  # Center
    )
    
    title_text = f"Grievance Report - {filter_type.capitalize()}"
    if user_id:
        user = User.query.get(user_id)
        title_text += f" - User: {user.name if user else 'Unknown'}"
    if area_id:
        area = MasterAreas.query.get(area_id)
        title_text += f" - Area: {area.name if area else 'Unknown'}"
    
    elements.append(Paragraph(title_text, title_style))
    
    # Add summary statistics
    summary_style = ParagraphStyle(
        'Summary',
        parent=styles['Normal'],
        fontSize=12,
        spaceAfter=12
    )
    
    query = Grievance.query
    if filter_type != 'all':
        now = datetime.utcnow()
        if filter_type == 'day':
            query = query.filter(Grievance.created_at >= now - timedelta(days=1))
        elif filter_type == 'week':
            query = query.filter(Grievance.created_at >= now - timedelta(weeks=1))
        elif filter_type == 'month':
            query = query.filter(Grievance.created_at >= now - timedelta(days=30))
        elif filter_type == 'year':
            query = query.filter(Grievance.created_at >= now - timedelta(days=365))
    
    if user_id:
        query = query.filter(Grievance.citizen_id == user_id)
    if area_id:
        query = query.filter(Grievance.area_id == area_id)
    
    try:
        summary_data = get_summary_statistics(query)
        summary_text = (
            f"Total Grievances: {summary_data.get('total_grievances', 0)} | "
            f"Resolved: {summary_data.get('resolved_count', 0)} | "
            f"Pending: {summary_data.get('pending_count', 0)}"
        )
        elements.append(Paragraph(summary_text, summary_style))
        elements.append(Spacer(1, 12))
    except Exception as e:
        elements.append(Paragraph(f"Error fetching summary: {str(e)}", summary_style))
        elements.append(Spacer(1, 12))
    
    # Add data table if there's data
    if not data.empty:
        # Prepare table data
        table_data = [list(data.columns)]
        for _, row in data.iterrows():
            table_data.append([str(val) for val in row])  # Convert all values to strings
        
        # Create table
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(table)
    
    # Build PDF
    try:
        doc.build(elements)
        pdf_content = buffer.getvalue()
    except Exception as e:
        buffer.close()
        raise Exception(f"Failed to generate PDF: {str(e)}")
    
    buffer.close()
    return pdf_content

def get_summary_statistics(query):
    """
    Get summary statistics for a query.

    Args:
        query: SQLAlchemy query object for grievances.

    Returns:
        dict: Summary statistics (total_grievances, resolved_count, pending_count).

    Raises:
        Exception: If query execution fails.
    """
    try:
        total_grievances = query.count()
        resolved_count = query.filter(Grievance.status == GrievanceStatus.CLOSED).count()
        pending_count = query.filter(Grievance.status.notin_([
            GrievanceStatus.CLOSED, 
            GrievanceStatus.REJECTED
        ])).count()
        
        return {
            'total_grievances': total_grievances or 0,
            'resolved_count': resolved_count or 0,
            'pending_count': pending_count or 0
        }
    except Exception as e:
        raise Exception(f"Failed to compute summary statistics: {str(e)}")

def get_advanced_kpis(time_period='all'):
    """
    Get advanced KPIs for the system.

    Args:
        time_period (str): Time period filter ('day', 'week', 'month', 'year', 'all').

    Returns:
        dict: Dictionary containing various KPIs (total_complaints, status_overview,
              dept_wise, sla_metrics, staff_performance).

    Raises:
        ValueError: If time_period is invalid.
        Exception: If database queries fail.
    """
    valid_periods = ['day', 'week', 'month', 'year', 'all']
    if time_period not in valid_periods:
        raise ValueError(f"Invalid time_period. Must be one of {valid_periods}")

    try:
        # Calculate time filter
        now = datetime.utcnow()
        if time_period == 'day':
            time_filter = Grievance.created_at >= now - timedelta(days=1)
        elif time_period == 'week':
            time_filter = Grievance.created_at >= now - timedelta(weeks=1)
        elif time_period == 'month':
            time_filter = Grievance.created_at >= now - timedelta(days=30)
        elif time_period == 'year':
            time_filter = Grievance.created_at >= now - timedelta(days=365)
        else:
            time_filter = True  # No filter for 'all'
        
        # Total complaints by time period
        total_complaints = {
            'day': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(days=1))
                    .scalar() or 0,
            'week': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(weeks=1))
                    .scalar() or 0,
            'month': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(days=30))
                    .scalar() or 0,
            'year': db.session.query(func.count(Grievance.id))
                    .filter(Grievance.created_at >= now - timedelta(days=365))
                    .scalar() or 0,
            'all': db.session.query(func.count(Grievance.id))
                    .scalar() or 0
        }
        
        # Status overview
        status_counts = db.session.query(
            Grievance.status, 
            func.count(Grievance.id)
        ).filter(time_filter).group_by(Grievance.status).all()
        status_overview = {status.value: count for status, count in status_counts}
        
        # Ensure all possible statuses are included
        for status in GrievanceStatus:
            if status.value not in status_overview:
                status_overview[status.value] = 0
        
        # Department-wise distribution
        dept_wise = dict(db.session.query(
            MasterAreas.name, 
            func.count(Grievance.id)
        ).join(Grievance, MasterAreas.id == Grievance.area_id)
        .filter(time_filter)
        .group_by(MasterAreas.id, MasterAreas.name).all())
        
        # SLA compliance metrics
        resolved_grievances = Grievance.query.filter(
            and_(Grievance.status == GrievanceStatus.CLOSED, time_filter)
        )
        
        sla_days = current_app.config.get('SLA_CLOSURE_DAYS', 7)
        sla_compliant = resolved_grievances.filter(
            Grievance.updated_at - Grievance.created_at <= timedelta(days=sla_days)
        ).count()
        
        total_resolved = resolved_grievances.count()
        sla_compliance_rate = (sla_compliant / total_resolved * 100) if total_resolved > 0 else 0
        
        # Staff performance
        staff_performance = dict(db.session.query(
            User.name, 
            func.count(Grievance.id)
        ).join(Grievance, User.id == Grievance.assigned_to)
        .filter(and_(Grievance.status == GrievanceStatus.CLOSED, time_filter))
        .group_by(User.id, User.name).all())
        
        # Average resolution time
        avg_resolution_time = db.session.query(
            func.avg(func.julianday(Grievance.updated_at) - func.julianday(Grievance.created_at))
        ).filter(and_(Grievance.status == GrievanceStatus.CLOSED, time_filter)).scalar() or 0
        
        return {
            'total_complaints': total_complaints,
            'status_overview': status_overview,
            'dept_wise': dept_wise or {},
            'sla_metrics': {
                'sla_days': sla_days,
                'sla_compliant': sla_compliant or 0,
                'total_resolved': total_resolved or 0,
                'sla_compliance_rate': round(sla_compliance_rate, 2),
                'avg_resolution_time_days': round(avg_resolution_time, 2)
            },
            'staff_performance': staff_performance or {}
        }
    except Exception as e:
        raise Exception(f"Failed to compute KPIs: {str(e)}")

def get_citizen_history(user_id):
    """
    Get grievance history for a specific citizen.

    Args:
        user_id (int): ID of the citizen.

    Returns:
        list: List of grievance records.

    Raises:
        Exception: If query execution fails.
    """
    try:
        return Grievance.query.filter_by(citizen_id=user_id).all()
    except Exception as e:
        raise Exception(f"Failed to fetch citizen history: {str(e)}")

def escalate_grievance(grievance_id, escalated_by , new_assignee_id=None):
    """
    Escalate a grievance to a higher level.

    Args:
        grievance_id (int): ID of the grievance to escalate.
        escalated_by (int): ID of the user performing the escalation.

    Returns:
        dict: Result of the escalation operation.

    Raises:
        Exception: If the grievance is not found or escalation fails.
    """
    try:
        grievance = Grievance.query.get(grievance_id)
        if not grievance:
            return {"success": False, "message": "Grievance not found"}
        
        # Increment escalation level
        grievance.escalation_level = (grievance.escalation_level or 0) + 1
        
        # Update status
        grievance.status = GrievanceStatus.ON_HOLD
        
        # Optionally reassign to a new user
        if new_assignee_id:
            grievance.assigned_to = new_assignee_id
        
        # Log the escalation
        log_audit(f'Grievance escalated to level {grievance.escalation_level}', escalated_by, grievance_id)
        
        db.session.commit()
        
        # Notify administrators and new assignee (if applicable)
        admins = User.query.filter_by(role='admin').all()
        for admin in admins:
            send_notification(
                admin.email, 
                'Grievance Escalated', 
                f'Grievance #{grievance_id} has been escalated to level {grievance.escalation_level}'
            )
        if new_assignee_id:
            assignee = User.query.get(new_assignee_id)
            if assignee:
                send_notification(
                    assignee.email,
                    'Grievance Assigned',
                    f'You have been assigned escalated grievance #{grievance_id} (Level {grievance.escalation_level})'
                )
        
        return {"success": True, "message": f"Grievance escalated to level {grievance.escalation_level}"}
    except Exception as e:
        db.session.rollback()
        raise Exception(f"Failed to escalate grievance: {str(e)}")

def log_audit(action, user_id, grievance_id=None):
    """
    Log an audit action.

    Args:
        action (str): Description of the action.
        user_id (int): ID of the user performing the action.
        grievance_id (int, optional): ID of the related grievance.

    Raises:
        Exception: If audit logging fails.
    """
    try:
        log = AuditLog(action=action, performed_by=user_id, grievance_id=grievance_id)
        db.session.add(log)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        raise Exception(f"Failed to log audit: {str(e)}")

def get_staff_performance():
    """
    Generate staff performance metrics:
    - Total complaints assigned
    - Complaints resolved
    - Avg resolution time (hours)
    - Avg citizen feedback rating
    """

    query = (
        db.session.query(
            User.id.label("staff_id"),
            User.name.label("staff_name"),
            func.count(Grievance.id).label("total_assigned"),
            func.sum(case((Grievance.status == GrievanceStatus.CLOSED, 1), else_=0)).label("resolved_count"),
            func.avg(case((Grievance.status == GrievanceStatus.CLOSED,
                           func.strftime('%s', Grievance.resolved_at) - func.strftime('%s', Grievance.created_at)))).label("avg_resolution_time_seconds"),
            func.avg(Grievance.feedback_rating).label("avg_feedback_rating")
        )
        .join(User, User.id == Grievance.assigned_to)
        .filter(User.role == Role.EMPLOYER)
        .group_by(User.id, User.name)
    ).all()

    results = []
    for row in query:
        results.append({
            "staff_id": row.staff_id,
            "staff_name": row.staff_name,
            "total_assigned": int(row.total_assigned or 0),
            "resolved_count": int(row.resolved_count or 0),
            "avg_resolution_time_hours": round((row.avg_resolution_time_seconds or 0) / 3600, 2),
            "avg_feedback_rating": round(row.avg_feedback_rating or 0, 2)
        })
    return results

def get_location_reports():
    """
    Location-based grievance reports:
    - Complaints per ward
    - Complaints per geo-location cluster
    """
    ward_data = (
        db.session.query(
            Grievance.ward_number,
            func.count(Grievance.id).label("total_complaints"),
            func.sum(case((Grievance.status == GrievanceStatus.CLOSED, 1), else_=0)).label("resolved"),
            func.sum(case((Grievance.status.notin_([GrievanceStatus.CLOSED, GrievanceStatus.REJECTED]), 1), else_=0)).label("pending")
        )
        .group_by(Grievance.ward_number)
        .all()
    )

    return [
        {
            "ward_number": row.ward_number or "Unknown",
            "total_complaints": int(row.total_complaints or 0),
            "resolved": int(row.resolved or 0),
            "pending": int(row.pending or 0)
        }
        for row in ward_data
    ]

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\services\user_service.py ---
# app/services/user_service.py

from ..models import User, Role
from ..schemas import UserSchema
from .. import db

def add_update_user(data):
    schema = UserSchema()
    user_data = schema.load(data, partial=True)
    if 'id' in data and data['id']:
        user = db.session.get(User, data['id'])
        if not user:
            raise ValueError("User not found")
        for key, value in user_data.items():
            setattr(user, key, value)
    else:
        if User.query.filter_by(email=user_data.get('email')).first():
            raise ValueError("Email already exists")
        if User.query.filter_by(phone_number=user_data.get('phone_number')).first():
            raise ValueError("Phone number already exists")
        user = User(**user_data)
        db.session.add(user)
    if 'password' in data:
        user.set_password(data['password'])
    db.session.commit()
    return schema.dump(user)

def delete_user(user_id):
    user = db.session.get(User, user_id)
    if not user:
        raise ValueError("User not found")
    db.session.delete(user)
    db.session.commit()

=== Folder: app\services\__pycache__ ===


=== Folder: app\utils ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\utils\auth_utils.py ---
# app/utils/auth_utils.py

from functools import wraps
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity
from flask import jsonify
from ..models import User, Role
from .. import db
def jwt_required_with_role(roles):
    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            verify_jwt_in_request()
            current_user_id = get_jwt_identity()
            print(f"JWT Identity: {current_user_id}")
            user = db.session.get(User, current_user_id)
            if not user:
                print("User not found for ID:", current_user_id)
                return jsonify({"msg": "User not found"}), 404
            if user.role not in roles:
                print(f"Access forbidden: User role {user.role} not in {roles}")
                return jsonify({"msg": "Access forbidden"}), 403
            return fn(user, *args, **kwargs)
        return decorator
    return wrapper

# Role decorators
def citizen_required(fn):
    return jwt_required_with_role([Role.CITIZEN])(fn)

def member_head_required(fn):
    return jwt_required_with_role([Role.MEMBER_HEAD])(fn)

def field_staff_required(fn):
    return jwt_required_with_role([Role.FIELD_STAFF])(fn)

def admin_required(fn):
    return jwt_required_with_role([Role.ADMIN])(fn)
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\utils\file_utils.py ---
# app/utils/file_utils.py

import os
from werkzeug.utils import secure_filename
from flask import current_app
from mimetypes import guess_type

def allowed_file(filename):
    # Get MIME type of the file
    mime_type, _ = guess_type(filename)
    
    # Define allowed MIME types
    allowed_mime_types = [
        'image/jpeg',       # jpg/jpeg
        'image/png',        # png
        'application/pdf',  # pdf
        'text/plain',       # txt
        'video/mp4',        # mp4
        'video/quicktime'   # mov
    ]
    
    # Check file extension and MIME type
    return (
        '.' in filename and
        filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS'] and
        mime_type in allowed_mime_types
    )

def upload_files(files, grievance_id):
    uploaded_paths = []
    upload_folder = os.path.join(current_app.config['UPLOAD_FOLDER'], f'grievance_{grievance_id}')
    if not os.path.exists(upload_folder):
        os.makedirs(upload_folder)
    
    if len(files) > 10:
        raise ValueError("Maximum 10 files allowed")
    
    for file in files:
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            file_path = os.path.join(upload_folder, filename)
            file.save(file_path)
            file_size = os.path.getsize(file_path)
            uploaded_paths.append((file_path, filename.rsplit('.', 1)[1].lower(), file_size))
        else:
            raise ValueError("Invalid file type")
    
    return uploaded_paths

def upload_workproof(file, grievance_id):
    if not allowed_file(file.filename):
        raise ValueError("Invalid file type")
    
    upload_folder = os.path.join(current_app.config['UPLOAD_FOLDER'], f'workproof_{grievance_id}')
    if not os.path.exists(upload_folder):
        os.makedirs(upload_folder)
    
    filename = secure_filename(file.filename)
    file_path = os.path.join(upload_folder, filename)
    file.save(file_path)
    return file_path
--- File: D:\Company_Data\PCMCApp\grievance-system-backend\app\utils\kpi_utils.py ---
# app/utils/kpi_utils.py

from datetime import datetime, timedelta
from ..models import Grievance, GrievanceStatus, MasterAreas
from .. import db
from sqlalchemy import func

def calculate_resolution_rate():
    total_resolved = Grievance.query.filter_by(status=GrievanceStatus.CLOSED).count()
    total_grievances = Grievance.query.count()
    return (total_resolved / total_grievances * 100) if total_grievances > 0 else 0

def calculate_pending_aging():
    pending = Grievance.query.filter(Grievance.status.notin_([GrievanceStatus.CLOSED, GrievanceStatus.REJECTED]))
    aging = db.session.query(func.avg(func.julianday(datetime.utcnow()) - func.julianday(Grievance.created_at))).filter(Grievance.status.notin_([GrievanceStatus.CLOSED, GrievanceStatus.REJECTED])).scalar()
    return {
        'pending_count': pending.count(),
        'average_aging_days': aging or 0
    }

def calculate_sla_compliance():
    # Assuming SLA is resolution within 30 days for example
    resolved = Grievance.query.filter_by(status=GrievanceStatus.CLOSED)
    compliant = resolved.filter(Grievance.updated_at - Grievance.created_at <= timedelta(days=30)).count()
    total_resolved = resolved.count()
    return (compliant / total_resolved * 100) if total_resolved > 0 else 0

def calculate_dept_wise_resolution():
    return db.session.query(MasterAreas.name, func.avg(Grievance.updated_at - Grievance.created_at)).join(MasterAreas).group_by(MasterAreas.id).all()

=== Folder: app\utils\__pycache__ ===


=== Folder: app\__pycache__ ===


=== Folder: migrations ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\migrations\env.py ---
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


=== Folder: migrations\versions ===

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\migrations\versions\2f1f3f8372c2_initial_migration.py ---
"""Initial migration

Revision ID: 2f1f3f8372c2
Revises: 
Create Date: 2025-08-27 17:15:33.074414

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '2f1f3f8372c2'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('announcement',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=256), nullable=False),
    sa.Column('message', sa.Text(), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('master_areas',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=128), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('master_config',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('key', sa.String(length=128), nullable=False),
    sa.Column('value', sa.String(length=256), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('key')
    )
    op.create_table('master_subjects',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=128), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('otp_token',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('phone_number', sa.String(length=15), nullable=False),
    sa.Column('otp', sa.String(length=6), nullable=False),
    sa.Column('expires_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=128), nullable=False),
    sa.Column('email', sa.String(length=128), nullable=True),
    sa.Column('phone_number', sa.String(length=15), nullable=True),
    sa.Column('password_hash', sa.String(length=256), nullable=True),
    sa.Column('role', sa.Enum('CITIZEN', 'MEMBER_HEAD', 'FIELD_STAFF', 'ADMIN', name='role'), nullable=False),
    sa.Column('department_id', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['department_id'], ['master_areas.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email'),
    sa.UniqueConstraint('phone_number')
    )
    op.create_table('grievance',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('complaint_id', sa.String(length=50), nullable=False),
    sa.Column('citizen_id', sa.Integer(), nullable=False),
    sa.Column('subject_id', sa.Integer(), nullable=False),
    sa.Column('area_id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=256), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('ward_number', sa.String(length=50), nullable=True),
    sa.Column('latitude', sa.Float(), nullable=True),
    sa.Column('longitude', sa.Float(), nullable=True),
    sa.Column('address', sa.String(length=256), nullable=True),
    sa.Column('status', sa.Enum('NEW', 'IN_PROGRESS', 'ON_HOLD', 'RESOLVED', 'CLOSED', 'REJECTED', name='grievancestatus'), nullable=False),
    sa.Column('priority', sa.Enum('LOW', 'MEDIUM', 'HIGH', 'URGENT', name='priority'), nullable=True),
    sa.Column('assigned_to', sa.Integer(), nullable=True),
    sa.Column('assigned_by', sa.Integer(), nullable=True),
    sa.Column('rejection_reason', sa.Text(), nullable=True),
    sa.Column('resolved_at', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('escalation_level', sa.Integer(), nullable=True),
    sa.Column('feedback_rating', sa.Integer(), nullable=True),
    sa.Column('feedback_text', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['area_id'], ['master_areas.id'], ),
    sa.ForeignKeyConstraint(['assigned_by'], ['user.id'], ),
    sa.ForeignKeyConstraint(['assigned_to'], ['user.id'], ),
    sa.ForeignKeyConstraint(['citizen_id'], ['user.id'], ),
    sa.ForeignKeyConstraint(['subject_id'], ['master_subjects.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('complaint_id')
    )
    op.create_table('notification_token',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('fcm_token', sa.String(length=256), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('audit_log',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('action', sa.Text(), nullable=False),
    sa.Column('performed_by', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=True),
    sa.Column('timestamp', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.ForeignKeyConstraint(['performed_by'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('grievance_attachment',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=False),
    sa.Column('file_path', sa.String(length=256), nullable=False),
    sa.Column('file_type', sa.String(length=10), nullable=False),
    sa.Column('uploaded_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('grievance_comment',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('comment_text', sa.Text(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('workproof',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=False),
    sa.Column('uploaded_by', sa.Integer(), nullable=False),
    sa.Column('file_path', sa.String(length=256), nullable=False),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.Column('uploaded_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.ForeignKeyConstraint(['uploaded_by'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('workproof')
    op.drop_table('grievance_comment')
    op.drop_table('grievance_attachment')
    op.drop_table('audit_log')
    op.drop_table('notification_token')
    op.drop_table('grievance')
    op.drop_table('user')
    op.drop_table('otp_token')
    op.drop_table('master_subjects')
    op.drop_table('master_config')
    op.drop_table('master_areas')
    op.drop_table('announcement')
    # ### end Alembic commands ###

--- File: D:\Company_Data\PCMCApp\grievance-system-backend\migrations\versions\d466744f65bb_initial_migration.py ---
"""Initial migration

Revision ID: d466744f65bb
Revises: 2f1f3f8372c2
Create Date: 2025-08-27 17:39:04.626823

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'd466744f65bb'
down_revision = '2f1f3f8372c2'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('announcement',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=256), nullable=False),
    sa.Column('message', sa.Text(), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('master_areas',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=128), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('master_config',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('key', sa.String(length=128), nullable=False),
    sa.Column('value', sa.String(length=256), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('key')
    )
    op.create_table('master_subjects',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=128), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('otp_token',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('phone_number', sa.String(length=15), nullable=False),
    sa.Column('otp', sa.String(length=6), nullable=False),
    sa.Column('expires_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=128), nullable=False),
    sa.Column('email', sa.String(length=128), nullable=True),
    sa.Column('phone_number', sa.String(length=15), nullable=True),
    sa.Column('password_hash', sa.String(length=256), nullable=True),
    sa.Column('role', sa.Enum('CITIZEN', 'MEMBER_HEAD', 'FIELD_STAFF', 'ADMIN', name='role'), nullable=False),
    sa.Column('department_id', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['department_id'], ['master_areas.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email'),
    sa.UniqueConstraint('phone_number')
    )
    op.create_table('grievance',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('complaint_id', sa.String(length=50), nullable=False),
    sa.Column('citizen_id', sa.Integer(), nullable=False),
    sa.Column('subject_id', sa.Integer(), nullable=False),
    sa.Column('area_id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=256), nullable=False),
    sa.Column('description', sa.Text(), nullable=False),
    sa.Column('ward_number', sa.String(length=50), nullable=True),
    sa.Column('latitude', sa.Float(), nullable=True),
    sa.Column('longitude', sa.Float(), nullable=True),
    sa.Column('address', sa.String(length=256), nullable=True),
    sa.Column('status', sa.Enum('NEW', 'IN_PROGRESS', 'ON_HOLD', 'RESOLVED', 'CLOSED', 'REJECTED', name='grievancestatus'), nullable=False),
    sa.Column('priority', sa.Enum('LOW', 'MEDIUM', 'HIGH', 'URGENT', name='priority'), nullable=True),
    sa.Column('assigned_to', sa.Integer(), nullable=True),
    sa.Column('assigned_by', sa.Integer(), nullable=True),
    sa.Column('rejection_reason', sa.Text(), nullable=True),
    sa.Column('resolved_at', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('escalation_level', sa.Integer(), nullable=True),
    sa.Column('feedback_rating', sa.Integer(), nullable=True),
    sa.Column('feedback_text', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['area_id'], ['master_areas.id'], ),
    sa.ForeignKeyConstraint(['assigned_by'], ['user.id'], ),
    sa.ForeignKeyConstraint(['assigned_to'], ['user.id'], ),
    sa.ForeignKeyConstraint(['citizen_id'], ['user.id'], ),
    sa.ForeignKeyConstraint(['subject_id'], ['master_subjects.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('complaint_id')
    )
    op.create_table('notification_token',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('fcm_token', sa.String(length=256), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('audit_log',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('action', sa.Text(), nullable=False),
    sa.Column('performed_by', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=True),
    sa.Column('timestamp', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.ForeignKeyConstraint(['performed_by'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('grievance_attachment',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=False),
    sa.Column('file_path', sa.String(length=256), nullable=False),
    sa.Column('file_type', sa.String(length=10), nullable=False),
    sa.Column('uploaded_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('grievance_comment',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('comment_text', sa.Text(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('workproof',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('grievance_id', sa.Integer(), nullable=False),
    sa.Column('uploaded_by', sa.Integer(), nullable=False),
    sa.Column('file_path', sa.String(length=256), nullable=False),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.Column('uploaded_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['grievance_id'], ['grievance.id'], ),
    sa.ForeignKeyConstraint(['uploaded_by'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('workproof')
    op.drop_table('grievance_comment')
    op.drop_table('grievance_attachment')
    op.drop_table('audit_log')
    op.drop_table('notification_token')
    op.drop_table('grievance')
    op.drop_table('user')
    op.drop_table('otp_token')
    op.drop_table('master_subjects')
    op.drop_table('master_config')
    op.drop_table('master_areas')
    op.drop_table('announcement')
    # ### end Alembic commands ###


=== Folder: migrations\versions\__pycache__ ===


=== Folder: migrations\__pycache__ ===


=== Folder: uploads ===


=== Folder: uploads\grievance_1 ===


=== Folder: uploads\grievance_2 ===


=== Folder: uploads\grievance_3 ===


=== Folder: uploads\grievance_4 ===


=== Folder: uploads\grievance_5 ===


=== Folder: uploads\grievance_6 ===


=== Folder: uploads\grievance_7 ===


=== Folder: uploads\grievance_8 ===


=== Folder: uploads\grievance_9 ===
